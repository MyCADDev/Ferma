{
    "docs": [
        {
            "location": "/", 
            "text": "An ORM / OGM for the TinkerPop graph stack.\n\n\nLicensed under the Apache Software License v2\n\n\nThe Ferma project was originally created as an alternative to the\nTinkerPop2 Frames project. Which at the time lacked features needed by\nthe community, and its performance was cripplingly slow. Today Ferma is\na robust framework that takes on a role similar to an Object-relational\nModel (ORM) library for traditional databases. Ferma is often referred\nto as a Object-graph Model (OGM) library, and maps Java objects to\nelements in a graph such as a Vertex or an Edges. In short it allows a\nschema to be defined using java interfaces and classes which provides a\nlevel of abstraction for interacting with the underlying graph.\n\n\nFerma 3.x \nSupports TinkerPop3\n. For tinkerPop2 support use Ferma\nversion 2.x.\n\n\nAnnotated classes in Ferma have their abstract methods implemented using\ncode generation during start-up with Byte Buddy, avoiding the need for\nproxy classes. This in turn significantly improves performance when\ncompared with TinkerPop Frames and other frameworks. Ferma offers many\nfeatures including several annotation types to reduce the need for\nboilerplate code as well as handling Java typing transparently. This\nensures whatever the type of the object is when you persist it to the\ngraph the same Java type will be used when instantiating a class off of\nthe graph.\n\n\nFerma is designed to easily replace TinkerPop Frames in existing code,\nas such, the annotations provided by Ferma are a super-set of those\nprovided by TinkerPop Frames.\n\n\nFerma is built directly on top of TinkerPop and allows access to all of\nthe internals. This ensures all the TinkerPop features are available to\nthe end-user. The TinkerPop stack provides several tools which can be\nused to work with the Ferma engine.\n\n\n\n\nGremlin\n, a database agnostic query language for Graph Databases.\n\n\nGremlin Server\n, a server that provides an interface for\n    executing Gremlin on remote machines.\n\n\na data-flow framework for splitting, merging, filtering, and\n    transforming of data\n\n\nGraph Computer\n, a framework for running algorithms against a\n    Graph Database.\n\n\nSupport for both \nOLTP\n and \nOLAP\n engines.\n\n\nTinkerGraph\n a Graph Database and the reference implementation\n    for TinkerPop.\n\n\nNative \nGephi\n integration for visualizing graphs.\n\n\nInterfaces for most major Graph Compute Engines including \nHadoop\n    M/R\n. \nSpark\n, and \nGiraph\n.\n\n\n\n\nFerma also supports any of the many databases compatible with TinkerPop\nincluding the following.\n\n\n\n\nTitan\n\n\nNeo4j\n\n\nOrientDB\n\n\nMongoDB\n\n\nOracle NoSQL\n\n\nTinkerGraph\n\n\n\n\nFerma Javadocs:\n\nlatest\n -\n\n3.1.0\n -\n\n3.0.3\n -\n\n3.0.2\n -\n\n3.0.1\n -\n\n3.0.0\n -\n\n2.4.0\n -\n\n2.3.0\n -\n\n2.2.2\n -\n\n2.2.1\n -\n\n2.2.0\n -\n\n2.1.0\n -\n\n2.0.6\n -\n\n2.0.5\n -\n\n2.0.4\n -\n\n2.0.3\n -\n\n2.0.2\n -\n\n2.0.1\n -\n\n2.0.0\n\n\nFor support please use\n\nGitter\n\nor the \nofficial Ferma mailing list\n.\n\n\nPlease file bugs and feature requests on\n\nGithub\n.\n\n\nObtaining the Source\n\n\nThe official source repository for Ferma is located in the Syncleus\nGithub repository and can be cloned using the following command.\n\n\ngit clone https://github.com/Syncleus/Ferma.git", 
            "title": "Home"
        }, 
        {
            "location": "/#obtaining-the-source", 
            "text": "The official source repository for Ferma is located in the Syncleus\nGithub repository and can be cloned using the following command.  git clone https://github.com/Syncleus/Ferma.git", 
            "title": "Obtaining the Source"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Ferma provides three levels of type resolution: untyped, simple, and annotated. In untyped mode Ferma doesn't handle\ntyping at all, instead the type must be explicitly indicated whenever querying. In simple mode Ferma provides type\ncontext encoded as graph element properties which ensures the same type comes out that goes in to a graph. In annotated\nmode all the features of simple mode are provided as well as enabling the use of annotations on abstract methods to\ninstruct Ferma to dynamically construct byte code to implement the abstract methods at start up.\n\n\nDependency\n\n\nTo include Ferma in your project of choice include the following Maven dependency into your build.\n\n\ndependency\n\n    \ngroupId\ncom.syncleus.ferma\n/groupId\n\n    \nartifactId\nferma\n/artifactId\n\n    \nversion\n3.2.0\n/version\n\n\n/dependency\n\n\n\n\n\nUntyped Mode Example\n\n\nIn untyped mode there is no automatic typing. Whatever class is explicitly indicated is the type that will be\ninstantiated when performing queries. Lets start with a simple example domain.\n\n\npublic\n \nclass\n \nPerson\n \nextends\n \nVertexFrame\n \n{\n\n  \npublic\n \nString\n \ngetName\n()\n \n{\n\n    \nreturn\n \ngetProperty\n(\nname\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetName\n(\nString\n \nname\n)\n \n{\n\n    \nsetProperty\n(\nname\n,\n \nname\n);\n\n  \n}\n\n\n  \npublic\n \nList\n?\n \nextends\n \nKnows\n \ngetKnowsList\n()\n \n{\n\n    \nreturn\n \ntraverse\n((\nv\n)\n \n-\n \nv\n.\noutE\n(\nknows\n)).\ntoList\n(\nKnows\n.\nclass\n);\n\n  \n}\n\n\n  \npublic\n \nKnows\n \naddKnows\n(\nPerson\n \nfriend\n)\n \n{\n\n    \nreturn\n \naddEdge\n(\nknows\n,\n \nfriend\n,\n \nKnows\n.\nclass\n);\n\n  \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nKnows\n \nextends\n \nEdgeFrame\n \n{\n\n  \npublic\n \nvoid\n \nsetYears\n(\nint\n \nyears\n)\n \n{\n\n    \nsetProperty\n(\nyears\n,\n \nyears\n);\n\n  \n}\n\n\n  \npublic\n \nint\n \ngetYears\n()\n \n{\n\n    \nreturn\n \ngetProperty\n(\nyears\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nAnd here is how you interact with the framed elements:\n\n\npublic\n \nvoid\n \ntestUntyped\n()\n \n{\n\n  \nGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\n  \n// implies untyped mode\n\n  \nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n);\n\n\n  \nPerson\n \np1\n \n=\n \nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n  \np1\n.\nsetName\n(\nJeff\n);\n\n\n  \nPerson\n \np2\n \n=\n \nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n  \np2\n.\nsetName\n(\nJulia\n);\n\n  \nKnows\n \nknows\n \n=\n \np1\n.\naddKnows\n(\np2\n);\n\n  \nknows\n.\nsetYears\n(\n15\n);\n\n\n  \nPerson\n \njeff\n \n=\n \nfg\n.\ntraverse\n((\ng\n)\n \n-\n \ng\n.\nV\n().\nhas\n(\nname\n,\n \nJeff\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n\n\n  \nAssert\n.\nassertEquals\n(\nJeff\n,\n \njeff\n.\ngetName\n());\n\n\n}\n\n\n\n\n\nSimple Mode Example\n\n\nIn simple mode you must provide concrete classes, no abstract or interfaces allowed, and the class should always extend\nfrom a FramedVertex or FramedEdge. Simple mode doesn't provide any annotations either. The purpose of simple mode is to\nprovide type resolution. Basically the type of object you use when adding to the graph is the same type you get out when\nreading from the graph.\n\n\nSay we extend the Person class with the Programmer class.\n\n\npublic\n \nclass\n \nProgrammer\n \nextends\n \nPerson\n \n{\n\n\n}\n\n\n\n\n\nUsing simple mode will save the type of Java class the element was created with for use later:\n\n\npublic\n \nvoid\n \ntestSimpleTyping\n()\n \n{\n\n  \nGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\n  \n// implies simple mode\n\n  \nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntrue\n,\n \nfalse\n);\n\n\n  \nPerson\n \np1\n \n=\n \nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n  \np1\n.\nsetName\n(\nJeff\n);\n\n\n  \nPerson\n \np2\n \n=\n \nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n  \np2\n.\nsetName\n(\nJulia\n);\n\n\n  \nPerson\n \njeff\n \n=\n \nfg\n.\ntraverse\n((\ng\n)\n \n-\n \ng\n.\nV\n().\nhas\n(\nname\n,\n \nJeff\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n  \nPerson\n \njulia\n \n=\n \nfg\n.\ntraverse\n((\ng\n)\n \n-\n \ng\n.\nV\n().\nhas\n(\nname\n,\n \nJulia\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n\n  \nAssert\n.\nassertEquals\n(\nProgrammer\n.\nclass\n,\n \njeff\n.\ngetClass\n());\n\n  \nAssert\n.\nassertEquals\n(\nPerson\n.\nclass\n,\n \njulia\n.\ngetClass\n());\n\n\n}\n\n\n\n\n\nAnnotated Mode Example\n\n\nIn annotated mode you can either provide concrete classes, abstract classes, or even interfaces. Abstract classes and\nconcrete classes must extend from FramedVertex or FramedEdge, however, interfaces do not have this restriction.\nAnnotated mode also provides a set of annotations which must be used to define any abstract methods that are to be\nimplemented by the engine. Annotated mode provides the same type resolution as provided by simple mode with a bit more\npower to determine parent-child relationships at run time.\n\n\nThe same example as above done with annotations would look something like this.\n\n\npublic\n \nabstract\n \nclass\n \nPerson\n \nextends\n \nVertexFrame\n \n{\n\n  \n@Property\n(\nname\n)\n\n  \npublic\n \nabstract\n \nString\n \ngetName\n();\n\n\n  \n@Property\n(\nname\n)\n\n  \npublic\n \nabstract\n \nvoid\n \nsetName\n(\nString\n \nname\n);\n\n\n  \n@Adjacency\n(\nknows\n)\n\n  \npublic\n \nabstract\n \nIterator\nPerson\n;\n \ngetKnowsPeople\n();\n\n\n  \n@Incidence\n(\nknows\n)\n\n  \npublic\n \nabstract\n \nIterator\nKnows\n \ngetKnows\n();\n\n\n  \n@Incidence\n(\nknows\n)\n\n  \npublic\n \nabstract\n \nKnows\n \naddKnows\n(\nPerson\n \nfriend\n);\n\n\n  \npublic\n \nList\nPerson\n \ngetFriendsNamedBill\n()\n \n{\n\n    \nreturn\n \ntraverse\n((\nv\n)\n \n-\n \nv\n.\nout\n(\nknows\n).\nhas\n(\nname\n,\n \nbill\n).\ntoList\n(\nPerson\n.\nclass\n);\n\n  \n}\n\n\n}\n\n\n\npublic\n \nabstract\n \nclass\n \nKnows\n \nextends\n \nEdgeFrame\n \n{\n\n  \n@Property\n(\nyears\n)\n\n  \npublic\n \nabstract\n \nvoid\n \nsetYears\n(\nint\n \nyears\n);\n\n\n  \n@Property\n(\nyears\n)\n\n  \npublic\n \nabstract\n \nint\n \ngetYears\n();\n\n\n  \n@InVertex\n\n  \npublic\n \nabstract\n \nPerson\n \ngetIn\n();\n\n\n  \n@OutVertex\n\n  \npublic\n \nabstract\n \nPerson\n \ngetIn\n();\n\n\n}\n\n\n\npublic\n \nabstract\n \nclass\n \nProgrammer\n \nextends\n \nPerson\n \n{\n\n\n}\n\n\n\n\n\nIf we pass a collection of Class objects to the FramedGraph constructor then the annotated type resolver will be used.\nIn this mode you want to tell the engine what classes you will be using so it can handle type resolution properly and\nconstruct the byte code for any abstract annotated methods.\n\n\npublic\n \nvoid\n \ntestAnnotatedTyping\n()\n \n{\n\n  \nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\n\n                                                                    \nPerson\n.\nclass\n,\n\n                                                                    \nProgrammer\n.\nclass\n,\n\n                                                                    \nKnows\n.\nclass\n}));\n\n  \nGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\n  \n//implies annotated mode\n\n  \nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntrue\n,\n \ntypes\n);\n\n\n  \nPerson\n \np1\n \n=\n \nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n  \np1\n.\nsetName\n(\nJeff\n);\n\n\n  \nPerson\n \np2\n \n=\n \nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n  \np2\n.\nsetName\n(\nJulia\n);\n\n\n  \nPerson\n \njeff\n \n=\n \nfg\n.\ntraverse\n((\ng\n)\n \n-\n \ng\n.\nV\n().\nhas\n(\nname\n,\n \nJeff\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n  \nPerson\n \njulia\n \n=\n \nfg\n.\ntraverse\n((\ng\n)\n \n-\n \ng\n.\nV\n().\nhas\n(\nname\n,\n \nJulia\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n\n  \nAssert\n.\nassertEquals\n(\nProgrammer\n.\nclass\n,\n \njeff\n.\ngetClass\n());\n\n  \nAssert\n.\nassertEquals\n(\nPerson\n.\nclass\n,\n \njulia\n.\ngetClass\n());\n\n\n}", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#dependency", 
            "text": "To include Ferma in your project of choice include the following Maven dependency into your build.  dependency \n     groupId com.syncleus.ferma /groupId \n     artifactId ferma /artifactId \n     version 3.2.0 /version  /dependency", 
            "title": "Dependency"
        }, 
        {
            "location": "/getting_started/#untyped-mode-example", 
            "text": "In untyped mode there is no automatic typing. Whatever class is explicitly indicated is the type that will be\ninstantiated when performing queries. Lets start with a simple example domain.  public   class   Person   extends   VertexFrame   { \n   public   String   getName ()   { \n     return   getProperty ( name ); \n   } \n\n   public   void   setName ( String   name )   { \n     setProperty ( name ,   name ); \n   } \n\n   public   List ?   extends   Knows   getKnowsList ()   { \n     return   traverse (( v )   -   v . outE ( knows )). toList ( Knows . class ); \n   } \n\n   public   Knows   addKnows ( Person   friend )   { \n     return   addEdge ( knows ,   friend ,   Knows . class ); \n   }  }  public   class   Knows   extends   EdgeFrame   { \n   public   void   setYears ( int   years )   { \n     setProperty ( years ,   years ); \n   } \n\n   public   int   getYears ()   { \n     return   getProperty ( years ); \n   }  }   And here is how you interact with the framed elements:  public   void   testUntyped ()   { \n   Graph   g   =   new   TinkerGraph (); \n\n   // implies untyped mode \n   FramedGraph   fg   =   new   DelegatingFramedGraph ( g ); \n\n   Person   p1   =   fg . addFramedVertex ( Person . class ); \n   p1 . setName ( Jeff ); \n\n   Person   p2   =   fg . addFramedVertex ( Person . class ); \n   p2 . setName ( Julia ); \n   Knows   knows   =   p1 . addKnows ( p2 ); \n   knows . setYears ( 15 ); \n\n   Person   jeff   =   fg . traverse (( g )   -   g . V (). has ( name ,   Jeff )). next ( Person . class ); \n\n\n   Assert . assertEquals ( Jeff ,   jeff . getName ());  }", 
            "title": "Untyped Mode Example"
        }, 
        {
            "location": "/getting_started/#simple-mode-example", 
            "text": "In simple mode you must provide concrete classes, no abstract or interfaces allowed, and the class should always extend\nfrom a FramedVertex or FramedEdge. Simple mode doesn't provide any annotations either. The purpose of simple mode is to\nprovide type resolution. Basically the type of object you use when adding to the graph is the same type you get out when\nreading from the graph.  Say we extend the Person class with the Programmer class.  public   class   Programmer   extends   Person   {  }   Using simple mode will save the type of Java class the element was created with for use later:  public   void   testSimpleTyping ()   { \n   Graph   g   =   new   TinkerGraph (); \n\n   // implies simple mode \n   FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   true ,   false ); \n\n   Person   p1   =   fg . addFramedVertex ( Programmer . class ); \n   p1 . setName ( Jeff ); \n\n   Person   p2   =   fg . addFramedVertex ( Person . class ); \n   p2 . setName ( Julia ); \n\n   Person   jeff   =   fg . traverse (( g )   -   g . V (). has ( name ,   Jeff )). next ( Person . class ); \n   Person   julia   =   fg . traverse (( g )   -   g . V (). has ( name ,   Julia )). next ( Person . class ); \n\n   Assert . assertEquals ( Programmer . class ,   jeff . getClass ()); \n   Assert . assertEquals ( Person . class ,   julia . getClass ());  }", 
            "title": "Simple Mode Example"
        }, 
        {
            "location": "/getting_started/#annotated-mode-example", 
            "text": "In annotated mode you can either provide concrete classes, abstract classes, or even interfaces. Abstract classes and\nconcrete classes must extend from FramedVertex or FramedEdge, however, interfaces do not have this restriction.\nAnnotated mode also provides a set of annotations which must be used to define any abstract methods that are to be\nimplemented by the engine. Annotated mode provides the same type resolution as provided by simple mode with a bit more\npower to determine parent-child relationships at run time.  The same example as above done with annotations would look something like this.  public   abstract   class   Person   extends   VertexFrame   { \n   @Property ( name ) \n   public   abstract   String   getName (); \n\n   @Property ( name ) \n   public   abstract   void   setName ( String   name ); \n\n   @Adjacency ( knows ) \n   public   abstract   Iterator Person ;   getKnowsPeople (); \n\n   @Incidence ( knows ) \n   public   abstract   Iterator Knows   getKnows (); \n\n   @Incidence ( knows ) \n   public   abstract   Knows   addKnows ( Person   friend ); \n\n   public   List Person   getFriendsNamedBill ()   { \n     return   traverse (( v )   -   v . out ( knows ). has ( name ,   bill ). toList ( Person . class ); \n   }  }  public   abstract   class   Knows   extends   EdgeFrame   { \n   @Property ( years ) \n   public   abstract   void   setYears ( int   years ); \n\n   @Property ( years ) \n   public   abstract   int   getYears (); \n\n   @InVertex \n   public   abstract   Person   getIn (); \n\n   @OutVertex \n   public   abstract   Person   getIn ();  }  public   abstract   class   Programmer   extends   Person   {  }   If we pass a collection of Class objects to the FramedGraph constructor then the annotated type resolver will be used.\nIn this mode you want to tell the engine what classes you will be using so it can handle type resolution properly and\nconstruct the byte code for any abstract annotated methods.  public   void   testAnnotatedTyping ()   { \n   Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ \n                                                                     Person . class , \n                                                                     Programmer . class , \n                                                                     Knows . class })); \n   Graph   g   =   new   TinkerGraph (); \n\n   //implies annotated mode \n   FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   true ,   types ); \n\n   Person   p1   =   fg . addFramedVertex ( Programmer . class ); \n   p1 . setName ( Jeff ); \n\n   Person   p2   =   fg . addFramedVertex ( Person . class ); \n   p2 . setName ( Julia ); \n\n   Person   jeff   =   fg . traverse (( g )   -   g . V (). has ( name ,   Jeff )). next ( Person . class ); \n   Person   julia   =   fg . traverse (( g )   -   g . V (). has ( name ,   Julia )). next ( Person . class ); \n\n   Assert . assertEquals ( Programmer . class ,   jeff . getClass ()); \n   Assert . assertEquals ( Person . class ,   julia . getClass ());  }", 
            "title": "Annotated Mode Example"
        }, 
        {
            "location": "/comparing_the_alternatives/", 
            "text": "There are several OGM/ORM options out there. For the purposes of this document we will focus only on those that have a\nstable release, or are close to a stable release. At the time of this writing those are: Tinkerpop Framed and Totorom.\n\n\nBenchmarks\n\n\nWe maintain an informal project for benchmarking Ferma against other OGM available, you can find the\n\nsource here\n. However below is a matrix breakdown of the results. Instead\nof showing raw execution time we show the ratio of each OGM compared to Ferma. Therefore if the table lists 1x then it\nmeans the framework has the same execution time as Ferma, if it lists 2x then it took twice as long to execute, and if\nit indicates 0.5x then it took half the time to execute. Obviously any value less than 1x indicates the OGM out\nperformed Ferma and any value greater than 1x indicates Ferma had the superior performance tiimes.\n\n\n\n\n\n\n\n\n\n\nBlueprints\n\n\nGremlin Pipeline\n\n\nTinkerpop3\n\n\nFrames\n\n\nTotorom\n\n\nPeapod\n\n\n\n\n\n\n\n\n\n\nGet adjacencies via annotation\n\n\nNot capable\n\n\nNot capable\n\n\nNot capable\n\n\nx2.09\n\n\nNot capable\n\n\nx2.65\n\n\n\n\n\n\nGet verticies (untyped)\n\n\nx0.89\n\n\nx3.94\n\n\nx16.98\n\n\nNot capable\n\n\nx4.24\n\n\nNot capable\n\n\n\n\n\n\nGet verticies (typed)\n\n\nx0.92\n\n\nx3.94\n\n\nNot capable\n\n\nx0.96\n\n\nx4.20\n\n\nx20.74\n\n\n\n\n\n\nGet verticies and call next (untyped)\n\n\nx0.79\n\n\nx3.87\n\n\nx11.74\n\n\nNot capable\n\n\nx4.81\n\n\nNot capable\n\n\n\n\n\n\nGet verticies and call next (typed)\n\n\nx0.72\n\n\nx2.91\n\n\nNot capable\n\n\nx1.94\n\n\nx3.31\n\n\nx16.70\n\n\n\n\n\n\n\n\nAs can be seen Ferma out performs all the alternative solutions considerably by several orders of magnitude. While\nresults do vary slightly from system to system these results are pretty close to typical. Go ahead, check out the\nbenchmark program and run it for yourself!\n\n\nFeature Breakdown\n\n\nDespite the superior performance of Ferma it also supports all the features provided by the alternatives out there, not\nto mention several novel features. The following gives a quick breakdown of the features of the various frameworks. We\nalso include a bit later in the document some Ferma examples showing the various features in action. All of the examples\nbelow use the domain model \nfound here\n.\n\n\n\n\n\n\n\n\n\n\nFerma\n\n\nFrames\n\n\nTotorom\n\n\nPeapod\n\n\n\n\n\n\n\n\n\n\nJPA-like Annotations\n\n\nSupported\n\n\nSupported\n\n\nNot Supported\n\n\nSupported\n\n\n\n\n\n\nType information encoded into graph\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\n\n\n\n\nFraming of elements instantiated according to type hierarchy\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\n\n\n\n\nElement queried by type hierarchy\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nPartial *\n\n\n\n\n\n\nTurning off type resolution on a per call basis\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nNot Supported\n\n\n\n\n\n\nChanging the encoded graph type already stored in the database\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nNot Supported\n\n\n\n\n\n\nCustomizing the way type information is stored in the graph\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nNot Supported\n\n\n\n\n\n\nTinkerpop 2 support\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\nNot Supported\n\n\n\n\n\n\nTinkerpop 3 support\n\n\nNot Supported\n\n\nNot Supported\n\n\nNot Supported\n\n\nSupported\n\n\n\n\n\n\n\n\n* While Peapod does support querying for all instances of a type, and its subtypes, it does not support a mechanism to\nquery for a specific type while excluding subtypes.\n\n\nType information encoded into graph\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n}));\n\n\nGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntypes\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n\nPerson\n \nperson\n \n=\n \nfg\n.\nv\n().\nnext\n(\nProgram\n.\nclass\n);\n\n\n\nString\n \npersonClassName\n \n=\n \nPerson\n.\nclass\n.\ngetName\n();\n\n\nString\n \nencodedClassName\n \n=\n \nperson\n.\ngetProperty\n(\nPolymorphicTypeResolver\n.\nTYPE_RESOLUTION_KEY\n)\n\n\nassert\n(\npersonClassName\n.\nequals\n(\nencodedClassName\n));\n\n\n\n\n\nFraming instantiated by type hierarchy\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n,\n\n                                                                         \nProgrammer\n.\nclass\n}));\n\n\nTinkerGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntypes\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n\n\n//make sure the newly added node is actually a programmer\n\n\nPerson\n \nprogrammer\n \n=\n \nfg\n.\nv\n().\nnext\n(\nPerson\n.\nclass\n);\n\n\nassert\n(\nprogrammer\n \ninstanceof\n \nProgrammer\n);\n\n\n\n\n\nElement queried by type hierarchy\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n,\n\n                                                                         \nProgrammer\n.\nclass\n}));\n\n\nTinkerGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntypes\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n\nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n\n\n//counts how many people (or subclasses thereof) in the graph.\n\n\nassert\n(\nfg\n.\nv\n().\nhas\n(\nPerson\n.\nclass\n).\ncount\n()\n \n==\n \n2\n);\n\n\n//counts how many programmers are in the graph\n\n\nassert\n(\nfg\n.\nv\n().\nhas\n(\nProgrammer\n.\nclass\n).\ncount\n()\n \n==\n \n1\n);\n\n\n\n\n\nTurning off type resolution per call\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n,\n\n                                                                         \nProgrammer\n.\nclass\n}));\n\n\nTinkerGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntypes\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n\n\n//With type resolution is active it should be a programmer\n\n\nassert\n(\nfg\n.\nv\n().\nnext\n(\nPerson\n.\nclass\n)\n \ninstanceof\n \nProgrammer\n);\n\n\n//With type resolution bypassed it is no longer a programmer\n\n\nassert\n(!(\nfg\n.\nv\n().\nnextExplicit\n(\nPerson\n.\nclass\n)\n \ninstanceof\n \nProgrammer\n));\n\n\n\n\n\nChanging type encoded in the graph\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n,\n\n                                                                         \nProgrammer\n.\nclass\n}));\n\n\nTinkerGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntypes\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n\n\n//make sure the newly added node is actually a programmer\n\n\nPerson\n \nprogrammer\n \n=\n \nfg\n.\nv\n().\nnext\n(\nPerson\n.\nclass\n);\n\n\nassert\n(\nprogrammer\n \ninstanceof\n \nProgrammer\n);\n\n\n\n//change the type resolution to person\n\n\nprogrammer\n.\nsetTypeResolution\n(\nPerson\n.\nclass\n);\n\n\n\n//make sure the newly added node is actually a programmer\n\n\nPerson\n \nperson\n \n=\n \nfg\n.\nv\n().\nnext\n(\nPerson\n.\nclass\n);\n\n\nassert\n(\nperson\n \ninstanceof\n \nPerson\n);\n\n\nassert\n(!(\nperson\n \ninstanceof\n \nProgrammer\n));\n\n\n\n\n\nCustomizing how types are encoded\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n}));\n\n\nfinal\n \nReflectionCache\n \ncache\n \n=\n \nnew\n \nReflectionCache\n(\ntypes\n);\n\n\nFrameFactory\n \nfactory\n \n=\n \nnew\n \nAnnotationFrameFactory\n(\ncache\n);\n\n\nTypeResolver\n \nresolver\n \n=\n \nnew\n \nPolymorphicTypeResolver\n(\ncache\n,\n \ncustomTypeKey\n);\n\n\nGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \nfactory\n,\n \nresolver\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n\nPerson\n \nperson\n \n=\n \nfg\n.\nv\n().\nnext\n(\nProgram\n.\nclass\n);\n\n\n\nString\n \npersonClassName\n \n=\n \nPerson\n.\nclass\n.\ngetName\n();\n\n\nString\n \nencodedClassName\n \n=\n \nperson\n.\ngetProperty\n(\ncustomTypeKey\n)\n\n\nassert\n(\npersonClassName\n.\nequals\n(\nencodedClassName\n));", 
            "title": "Comparing the Alternatives"
        }, 
        {
            "location": "/comparing_the_alternatives/#benchmarks", 
            "text": "We maintain an informal project for benchmarking Ferma against other OGM available, you can find the source here . However below is a matrix breakdown of the results. Instead\nof showing raw execution time we show the ratio of each OGM compared to Ferma. Therefore if the table lists 1x then it\nmeans the framework has the same execution time as Ferma, if it lists 2x then it took twice as long to execute, and if\nit indicates 0.5x then it took half the time to execute. Obviously any value less than 1x indicates the OGM out\nperformed Ferma and any value greater than 1x indicates Ferma had the superior performance tiimes.      Blueprints  Gremlin Pipeline  Tinkerpop3  Frames  Totorom  Peapod      Get adjacencies via annotation  Not capable  Not capable  Not capable  x2.09  Not capable  x2.65    Get verticies (untyped)  x0.89  x3.94  x16.98  Not capable  x4.24  Not capable    Get verticies (typed)  x0.92  x3.94  Not capable  x0.96  x4.20  x20.74    Get verticies and call next (untyped)  x0.79  x3.87  x11.74  Not capable  x4.81  Not capable    Get verticies and call next (typed)  x0.72  x2.91  Not capable  x1.94  x3.31  x16.70     As can be seen Ferma out performs all the alternative solutions considerably by several orders of magnitude. While\nresults do vary slightly from system to system these results are pretty close to typical. Go ahead, check out the\nbenchmark program and run it for yourself!", 
            "title": "Benchmarks"
        }, 
        {
            "location": "/comparing_the_alternatives/#feature-breakdown", 
            "text": "Despite the superior performance of Ferma it also supports all the features provided by the alternatives out there, not\nto mention several novel features. The following gives a quick breakdown of the features of the various frameworks. We\nalso include a bit later in the document some Ferma examples showing the various features in action. All of the examples\nbelow use the domain model  found here .      Ferma  Frames  Totorom  Peapod      JPA-like Annotations  Supported  Supported  Not Supported  Supported    Type information encoded into graph  Supported  Supported  Supported  Supported    Framing of elements instantiated according to type hierarchy  Supported  Supported  Supported  Supported    Element queried by type hierarchy  Supported  Not Supported  Not Supported  Partial *    Turning off type resolution on a per call basis  Supported  Not Supported  Not Supported  Not Supported    Changing the encoded graph type already stored in the database  Supported  Not Supported  Not Supported  Not Supported    Customizing the way type information is stored in the graph  Supported  Not Supported  Not Supported  Not Supported    Tinkerpop 2 support  Supported  Supported  Supported  Not Supported    Tinkerpop 3 support  Not Supported  Not Supported  Not Supported  Supported     * While Peapod does support querying for all instances of a type, and its subtypes, it does not support a mechanism to\nquery for a specific type while excluding subtypes.", 
            "title": "Feature Breakdown"
        }, 
        {
            "location": "/comparing_the_alternatives/#type-information-encoded-into-graph", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class }));  Graph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   types );  fg . addFramedVertex ( Person . class );  Person   person   =   fg . v (). next ( Program . class );  String   personClassName   =   Person . class . getName ();  String   encodedClassName   =   person . getProperty ( PolymorphicTypeResolver . TYPE_RESOLUTION_KEY )  assert ( personClassName . equals ( encodedClassName ));", 
            "title": "Type information encoded into graph"
        }, 
        {
            "location": "/comparing_the_alternatives/#framing-instantiated-by-type-hierarchy", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class , \n                                                                          Programmer . class }));  TinkerGraph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   types );  fg . addFramedVertex ( Programmer . class );  //make sure the newly added node is actually a programmer  Person   programmer   =   fg . v (). next ( Person . class );  assert ( programmer   instanceof   Programmer );", 
            "title": "Framing instantiated by type hierarchy"
        }, 
        {
            "location": "/comparing_the_alternatives/#element-queried-by-type-hierarchy", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class , \n                                                                          Programmer . class }));  TinkerGraph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   types );  fg . addFramedVertex ( Programmer . class );  fg . addFramedVertex ( Person . class );  //counts how many people (or subclasses thereof) in the graph.  assert ( fg . v (). has ( Person . class ). count ()   ==   2 );  //counts how many programmers are in the graph  assert ( fg . v (). has ( Programmer . class ). count ()   ==   1 );", 
            "title": "Element queried by type hierarchy"
        }, 
        {
            "location": "/comparing_the_alternatives/#turning-off-type-resolution-per-call", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class , \n                                                                          Programmer . class }));  TinkerGraph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   types );  fg . addFramedVertex ( Programmer . class );  //With type resolution is active it should be a programmer  assert ( fg . v (). next ( Person . class )   instanceof   Programmer );  //With type resolution bypassed it is no longer a programmer  assert (!( fg . v (). nextExplicit ( Person . class )   instanceof   Programmer ));", 
            "title": "Turning off type resolution per call"
        }, 
        {
            "location": "/comparing_the_alternatives/#changing-type-encoded-in-the-graph", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class , \n                                                                          Programmer . class }));  TinkerGraph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   types );  fg . addFramedVertex ( Programmer . class );  //make sure the newly added node is actually a programmer  Person   programmer   =   fg . v (). next ( Person . class );  assert ( programmer   instanceof   Programmer );  //change the type resolution to person  programmer . setTypeResolution ( Person . class );  //make sure the newly added node is actually a programmer  Person   person   =   fg . v (). next ( Person . class );  assert ( person   instanceof   Person );  assert (!( person   instanceof   Programmer ));", 
            "title": "Changing type encoded in the graph"
        }, 
        {
            "location": "/comparing_the_alternatives/#customizing-how-types-are-encoded", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class }));  final   ReflectionCache   cache   =   new   ReflectionCache ( types );  FrameFactory   factory   =   new   AnnotationFrameFactory ( cache );  TypeResolver   resolver   =   new   PolymorphicTypeResolver ( cache ,   customTypeKey );  Graph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   factory ,   resolver );  fg . addFramedVertex ( Person . class );  Person   person   =   fg . v (). next ( Program . class );  String   personClassName   =   Person . class . getName ();  String   encodedClassName   =   person . getProperty ( customTypeKey )  assert ( personClassName . equals ( encodedClassName ));", 
            "title": "Customizing how types are encoded"
        }, 
        {
            "location": "/annotations/overview/", 
            "text": "The Ferma schema is defined by a collection of interfaces and classes written by the user. Each method will interact\nwith the underlying graph to either modify the graph in some way, or to retrieve an element or property from the graph.\nThere are two techniques for defining how these methods behave. Either you can explicitly implement the method, or you\ncan leave the method as abstract and annotate the method in order to allow Ferma to implement the method for you. Here\nwe will define the annotations available to you and how they work, along with a few examples.\n\n\nThe behavior of an annotated method is dictated not only by the annotation applied to it but also the method's\nsignature. Therefore an annotated method will behave differently if it's return type, arguments, or even if the method\nname were to change. It is important to note that when a method is explicitly defined (doesnt use an annotation) then\nthe method signature can be anything.\n\n\nMethod names that are annotated must have one of the following prefixes: add, get, remove, set, is. Exactly which \nprefixes are varies from one annotation to the next so see the annotations detailed documentation to make that\ndetermination. It is also possible to override this behavior by setting the operation argument availible on most\nannotations which defaults to \nAUTO\n when not specified.", 
            "title": "Overview"
        }, 
        {
            "location": "/annotations/adjacency/", 
            "text": "Valid on frames: \nVertex\n\n\nAllowed prefixes when operation is AUTO: \nadd\n, \nget\n, \nremove\n, \nset\n\n\nAnnotation arguments:\n\n\nlabel\n - The label assigned to the edge which connects the adjacent nodes.\n\n\ndirection\n - The direction for the edge which creates the adjacency. It can be assigned any of the values from\n              \norg.apache.tinkerpop.gremlin.structure.Direction\n.\n\n\noperation\n - The operation the method will perform. Must be one of the following: \nGET\n, \nADD\n, \nSET\n, \nREMOVE\n,\n              \nAUTO\n. Defaults to \nAUTO\n.\n\n\nexample:\n\n\n@Adjacency\n(\nfoo\n)\n\n\n//Method declared here\n\n\n\n\n\nADD Operation\n\n\nValid method signatures: \n( )\n, \n(VertexFrame)\n, \n(ClassInitializer)\n, \n(ClassInitializer, ClassInitializer)\n,\n\n(VertexFrame, ClassInitializer)\n\n\nAdds a node as an adjacency to the current node, and the returns the newly connected node.\n\n\nSignature: \n( )\n\n\nValid return types: \nVertexFrame\n\n\nCreates a new vertex without any type information as well as an untyped edge to connect to it. The newly created\n\nVertexFrame\n is returned.\n\n\n\n\nNote\n\n\nSince the returned \nVertexFrame\n is always untyped the return type must be either \nVertexFrame\n or \nTVertex\n\nspecifically.\n\n\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nVertexFrame\n \naddFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nVertexFrame\n \nincludeFoobar\n();\n\n\n\n\n\nSignature: \n(VertexFrame)\n\n\nValid return types: \nVertexFrame\n or \nvoid\n\n\nCreates a new edge without any type information and connects it between this vertex the vertex specified as an argument\nto the method. The frame returned is the same as the frame given in the argument, it is only there for compatability\nwith other add methods. This method can also have a \nvoid\n return type.\n\n\nexamples:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \naddFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \naddFoobar\n(\nE\n \nexistingVertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \naddFoobar\n(\nE\n \nexistingVertex\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nvoid\n \nincludeFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\nSignature: \n(ClassInitializer)\n\n\nValid return types: \nVertexFrame\n\n\nCreates a new edge without any type information and connects it between this vertex and a newly created vertex. The\nnewly created vertex will have a type, as well as be initiated, according to the details specified in the\nClassInitializer argument. Java generics can, and should, be used to narrow the return type.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nE\n \nvertexInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nE\n \nvertexInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nBarVertex\n \nincludeFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n);\n\n\n\n\n\nSignature: \n(ClassInitializer, ClassInitializer)\n\n\nValid return types: \nVertexFrame\n\n\nCreates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be\ninitiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge\nwill hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                    \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nE\n \nvertexInitializer\n,\n\n                                  \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nE\n \nvertexInitializer\n,\n\n                                    \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nBarVertex\n \nincludeFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                        \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\nSignature: \n(VertexFrame, ClassInitializer)\n\n\nValid return types: \nVertexFrame\n or \nvoid\n\n\nCreates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be\ninitiated, according to the details specified in the \nClassInitializer\n argument. The \nVertexFrame\n specified in the first\nargument will simply be returned. A \nvoid\n return type is also valid. Java generics can, and should, be used\nto narrow the return type as well as to restrict the \nClassInitializer\n.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \naddFoobar\n(\nBarVertex\n \nvertex\n,\n\n                    \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \naddFoobar\n(\nE\n \nvertex\n,\n\n                                  \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \naddFoobar\n(\nBarVertex\n \nvertex\n,\n\n                                    \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nvoid\n \nincludeFoobar\n(\nBarVertex\n \nvertex\n,\n\n                        \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\nGET Operation\n\n\nValid method signatures: \n()\n, \n(Class)\n\n\nGet's one or more adjacent vertex from the graph.\n\n\nSignature: \n( )\n\n\nValid return types: \nVertexFrame\n or \nIterator\n or \nList\n or \nSet\n\n\nRetrieves one or more of the adjacent edges. If the return type is a single Frame then only the first instance is\nreturned. If the return type is an \nIterator\n or \nList\n or \nSet\n then it will supply all matching vertex. When using an\n\nIterator\n or \nList\n or \nSet\n it is encouraged, but not required, to use generics. The returned frames will always be\ninstantiated as the type encoded in the graph if there is one.\n\n\n\n\nNote\n\n\nIf a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown.\nTherefore the return type specifed should always by the same type, or a superclass, of the expected return type.\nVertexFrame is always a safe return type for this method.\n\n\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nIterator\nBarVertex\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nIterator\nE\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nIterator\nE\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nList\nBarVertex\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nSet\nBarVertex\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nGET\n)\n\n\nBarVertex\n \nobtainFoobar\n();\n\n\n\n\n\nSignature: \n(Class)\n\n\nValid return types: \nVertexFrame\n or \nIterator\n or \nList\n or \nSet\n\n\nRetrieves one or more of the adjacent vertex. If the return type is a single \nVertexFrame\n then only the first instance\nis returned. If the return type is an \nIterator\n then it will iterate over all matching vertex. When using an Iterator\nit is encouraged to use generics.\n\n\n\n\nNote\n\n\nThe Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype,\nto that of the argument will be returned.\n\n\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nBarVertex\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nIterator\nBarVertex\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nBarVertex\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nIterator\nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nIterator\nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nList\nBarVertex\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nBarVertex\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nSet\nBarVertex\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nBarVertex\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nGET\n)\n\n\nBarVertex\n \nobtainFoobar\n(\nClass\n?\n \nextends\n \nBarVertex\n \nfilter\n);\n\n\n\n\n\nREMOVE Operation\n\n\nValid method signatures: \n( )\n, \n(VertexFrame)\n\n\nRemoves any edges which cause an adjacency, leaving the vertex in place.\n\n\nSignature: \n( )\n\n\nValid return types: \nvoid\n\n\nRemoves all edges which create any adjacency between the current vertex and any other vertex using the specified label.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nremoveFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nREMOVE\n)\n\n\nvoid\n \ndeleteAllFoobar\n(\nE\n \nvertex\n);\n\n\n\n\n\nSignature: \n(VertexFrame)\n\n\nValid return types: \nvoid\n\n\nRemoves all edges which create an adjacency between the current vertex and the vertex specified in the methods argument\nand has the specified label.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nremoveFoobar\n(\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nvoid\n \nremoveFoobar\n(\nE\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nvoid\n \nremoveFoobar\n(\nE\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nREMOVE\n)\n\n\nvoid\n \nremoveFoobar\n(\nBarVertex\n \nvertex\n);\n\n\n\n\n\nSET Operation\n\n\nValid method signatures: \n(VertexFrame)\n, \n(Iterator)\n, \n(Iterable)\n\n\nCreates new edges connected to several vertex and at the same time removes any existing edges. If the any of the vertex\nbeing set are already an adjacency then the edge will be preserved as-is.\n\n\nSignature: \n(VertexFrame)\n\n\nValid return types: \nvoid\n\n\nThe argument for this method must be a \nVertexFrame\n or a class or interface which inherits from that class.\n\n\nThis method will drop any existing edges with the specified label and create a single new edge to the vertex specified.\nIf the specified vertex is already an adjacency than any edges already connected to it will be preserved. Any newly\ncreated edges will not encode a type.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nBarVertex\n \nvoid\n \nsetFoobar\n(\nE\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nSET\n)\n\n\nvoid\n \nassignFoobar\n(\nBarVertex\n \nvertex\n);\n\n\n\n\n\nSignature: \n(Iterator)\n\n\nValid return types: \nvoid\n\n\nThe argument for this method must be an \nIterator\n which iterates over vertex Frames. It is suggested you specify a\nGeneric Type for the Iterator for usability.\n\n\nThis method will iterate over all the vertex specified in the Iterator argument and create new edges to connect to it.\nThe edges in the graph will not encode a type.\n\n\nAny existing edges matching the specified label that do not connect to one of the \nVertexFrame\n provided by the iterator\nwill be removed.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nIterator\nBaBarVertexr\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nBarVertex\n \nvoid\n \nsetFoobar\n(\nIterator\n?\n \nextends\n \nE\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nSET\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nvoid\n \nincludeFoobar\n(\nIterator\n?\n \nextends\n \nE\n \nvertex\n);\n\n\n\n\n\nSignature: \n(Iterable)\n\n\nValid return types: \nvoid\n\n\nThe argument for this method must be an \nIterable\n or a subclass of \nIterable\n which iterates over vertex Frames. It is\nsuggested you specify a Generic Type for the Iterator for usability.\n\n\nSince all Java collections inherit from the \nIterable\n interface they can also be used as parameters to these methods.\n\n\nThis method will iterate over all the vertex specified in the \nIterable\n argument and create new edges to connect to it.\nThe edges in the graph will not encode a type.\n\n\nAny existing edges matching the specified label that do not connect to one of the \nVertexFrame\n provided by the iterator\nwill be removed.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nIterable\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nCollection\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nList\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nSet\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nBarVertex\n \nvoid\n \nsetFoobar\n(\nIterable\n?\n \nextends\n \nE\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nSET\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nvoid\n \nincludeFoobar\n(\nIterable\n?\n \nextends\n \nE\n \nvertex\n);", 
            "title": "@Adjacency"
        }, 
        {
            "location": "/annotations/adjacency/#add-operation", 
            "text": "Valid method signatures:  ( ) ,  (VertexFrame) ,  (ClassInitializer) ,  (ClassInitializer, ClassInitializer) , (VertexFrame, ClassInitializer)  Adds a node as an adjacency to the current node, and the returns the newly connected node.", 
            "title": "ADD Operation"
        }, 
        {
            "location": "/annotations/adjacency/#signature", 
            "text": "Valid return types:  VertexFrame  Creates a new vertex without any type information as well as an untyped edge to connect to it. The newly created VertexFrame  is returned.   Note  Since the returned  VertexFrame  is always untyped the return type must be either  VertexFrame  or  TVertex \nspecifically.   example:  @Adjacency ( Foo )  VertexFrame   addFoobar ();   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  VertexFrame   includeFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/adjacency/#signature-vertexframe", 
            "text": "Valid return types:  VertexFrame  or  void  Creates a new edge without any type information and connects it between this vertex the vertex specified as an argument\nto the method. The frame returned is the same as the frame given in the argument, it is only there for compatability\nwith other add methods. This method can also have a  void  return type.  examples:  @Adjacency ( Foo )  BarVertex   addFoobar ( BarVertex   existingVertex );   @Adjacency ( Foo )  E   extends   BarVertex   E   addFoobar ( E   existingVertex );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   VertexFrame   E   addFoobar ( E   existingVertex );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  void   includeFoobar ( BarVertex   existingVertex );", 
            "title": "Signature: (VertexFrame)"
        }, 
        {
            "location": "/annotations/adjacency/#signature-classinitializer", 
            "text": "Valid return types:  VertexFrame  Creates a new edge without any type information and connects it between this vertex and a newly created vertex. The\nnewly created vertex will have a type, as well as be initiated, according to the details specified in the\nClassInitializer argument. Java generics can, and should, be used to narrow the return type.  example:  @Adjacency ( Foo )  BarVertex   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer );   @Adjacency ( Foo )  E   extends   BarVertex   E   addFoobar ( ClassInitializer ?   extends   E   vertexInitializer );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   VertexFrame   E   addFoobar ( ClassInitializer ?   extends   E   vertexInitializer );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  BarVertex   includeFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer );", 
            "title": "Signature: (ClassInitializer)"
        }, 
        {
            "location": "/annotations/adjacency/#signature-classinitializer-classinitializer", 
            "text": "Valid return types:  VertexFrame  Creates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be\ninitiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge\nwill hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type.  example:  @Adjacency ( Foo )  BarVertex   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                     ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( Foo )  E   extends   BarVertex   E   addFoobar ( ClassInitializer ?   extends   E   vertexInitializer , \n                                   ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   VertexFrame   E   addFoobar ( ClassInitializer ?   extends   E   vertexInitializer , \n                                     ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  BarVertex   includeFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                         ClassInitializer ?   extends   FooEdge   edgeInitializer );", 
            "title": "Signature: (ClassInitializer, ClassInitializer)"
        }, 
        {
            "location": "/annotations/adjacency/#signature-vertexframe-classinitializer", 
            "text": "Valid return types:  VertexFrame  or  void  Creates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be\ninitiated, according to the details specified in the  ClassInitializer  argument. The  VertexFrame  specified in the first\nargument will simply be returned. A  void  return type is also valid. Java generics can, and should, be used\nto narrow the return type as well as to restrict the  ClassInitializer .  example:  @Adjacency ( Foo )  BarVertex   addFoobar ( BarVertex   vertex , \n                     ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( Foo )  E   extends   BarVertex   E   addFoobar ( E   vertex , \n                                   ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   VertexFrame   E   addFoobar ( BarVertex   vertex , \n                                     ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  void   includeFoobar ( BarVertex   vertex , \n                         ClassInitializer ?   extends   FooEdge   edgeInitializer );", 
            "title": "Signature: (VertexFrame, ClassInitializer)"
        }, 
        {
            "location": "/annotations/adjacency/#get-operation", 
            "text": "Valid method signatures:  () ,  (Class)  Get's one or more adjacent vertex from the graph.", 
            "title": "GET Operation"
        }, 
        {
            "location": "/annotations/adjacency/#signature_1", 
            "text": "Valid return types:  VertexFrame  or  Iterator  or  List  or  Set  Retrieves one or more of the adjacent edges. If the return type is a single Frame then only the first instance is\nreturned. If the return type is an  Iterator  or  List  or  Set  then it will supply all matching vertex. When using an Iterator  or  List  or  Set  it is encouraged, but not required, to use generics. The returned frames will always be\ninstantiated as the type encoded in the graph if there is one.   Note  If a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown.\nTherefore the return type specifed should always by the same type, or a superclass, of the expected return type.\nVertexFrame is always a safe return type for this method.   example:  @Adjacency ( Foo )  BarVertex   getFoobar ();   @Adjacency ( Foo )  E   extends   BarVertex   E   getFoobar ();   @Adjacency ( Foo )  E   extends   VertexFrame   E   getFoobar ();   @Adjacency ( Foo )  Iterator BarVertex   getFoobar ();   @Adjacency ( Foo )  E   extends   BarVertex   Iterator E   getFoobar ();   @Adjacency ( Foo )  E   extends   VertexFrame   Iterator E   getFoobar ();   @Adjacency ( Foo )  List BarVertex   getFoobar ();   @Adjacency ( Foo ,   direction   =   Direction . IN )  Set BarVertex   getFoobar ();   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . GET )  BarVertex   obtainFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/adjacency/#signature-class", 
            "text": "Valid return types:  VertexFrame  or  Iterator  or  List  or  Set  Retrieves one or more of the adjacent vertex. If the return type is a single  VertexFrame  then only the first instance\nis returned. If the return type is an  Iterator  then it will iterate over all matching vertex. When using an Iterator\nit is encouraged to use generics.   Note  The Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype,\nto that of the argument will be returned.   example:  @Adjacency ( Foo )  BarVertex   getFoobar ( Class ?   extends   BarVertex   filter );   @Adjacency ( Foo )  E   extends   BarVertex   E   getFoobar ( Class ?   extends   E   filter );   @Adjacency ( Foo )  E   extends   VertexFrame   E   getFoobar ( Class ?   extends   E   filter );   @Adjacency ( Foo )  Iterator BarVertex   getFoobar ( Class ?   extends   BarVertex   filter );   @Adjacency ( Foo )  E   extends   BarVertex   Iterator E   getFoobar ( Class ?   extends   E   filter );   @Adjacency ( Foo )  E   extends   VertexFrame   Iterator E   getFoobar ( Class ?   extends   E   filter );   @Adjacency ( Foo )  List BarVertex   getFoobar ( Class ?   extends   BarVertex   filter );   @Adjacency ( Foo ,   direction   =   Direction . IN )  Set BarVertex   getFoobar ( Class ?   extends   BarVertex   filter );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . GET )  BarVertex   obtainFoobar ( Class ?   extends   BarVertex   filter );", 
            "title": "Signature: (Class)"
        }, 
        {
            "location": "/annotations/adjacency/#remove-operation", 
            "text": "Valid method signatures:  ( ) ,  (VertexFrame)  Removes any edges which cause an adjacency, leaving the vertex in place.", 
            "title": "REMOVE Operation"
        }, 
        {
            "location": "/annotations/adjacency/#signature_2", 
            "text": "Valid return types:  void  Removes all edges which create any adjacency between the current vertex and any other vertex using the specified label.  example:  @Adjacency ( Foo )  void   removeFoobar ();   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . REMOVE )  void   deleteAllFoobar ( E   vertex );", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/adjacency/#signature-vertexframe_1", 
            "text": "Valid return types:  void  Removes all edges which create an adjacency between the current vertex and the vertex specified in the methods argument\nand has the specified label.  example:  @Adjacency ( Foo )  void   removeFoobar ( BarVertex   vertex );   @Adjacency ( Foo )  E   extends   BarVertex   void   removeFoobar ( E   vertex );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   VertexFrame   void   removeFoobar ( E   vertex );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . REMOVE )  void   removeFoobar ( BarVertex   vertex );", 
            "title": "Signature: (VertexFrame)"
        }, 
        {
            "location": "/annotations/adjacency/#set-operation", 
            "text": "Valid method signatures:  (VertexFrame) ,  (Iterator) ,  (Iterable)  Creates new edges connected to several vertex and at the same time removes any existing edges. If the any of the vertex\nbeing set are already an adjacency then the edge will be preserved as-is.", 
            "title": "SET Operation"
        }, 
        {
            "location": "/annotations/adjacency/#signature-vertexframe_2", 
            "text": "Valid return types:  void  The argument for this method must be a  VertexFrame  or a class or interface which inherits from that class.  This method will drop any existing edges with the specified label and create a single new edge to the vertex specified.\nIf the specified vertex is already an adjacency than any edges already connected to it will be preserved. Any newly\ncreated edges will not encode a type.  example:  @Adjacency ( Foo )  void   setFoobar ( BarVertex   vertex );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   BarVertex   void   setFoobar ( E   vertex );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . SET )  void   assignFoobar ( BarVertex   vertex );", 
            "title": "Signature: (VertexFrame)"
        }, 
        {
            "location": "/annotations/adjacency/#signature-iterator", 
            "text": "Valid return types:  void  The argument for this method must be an  Iterator  which iterates over vertex Frames. It is suggested you specify a\nGeneric Type for the Iterator for usability.  This method will iterate over all the vertex specified in the Iterator argument and create new edges to connect to it.\nThe edges in the graph will not encode a type.  Any existing edges matching the specified label that do not connect to one of the  VertexFrame  provided by the iterator\nwill be removed.  example:  @Adjacency ( Foo )  void   setFoobar ( Iterator BaBarVertexr   vertex );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   BarVertex   void   setFoobar ( Iterator ?   extends   E   vertex );   @Adjacency ( Foo ,   operation   =   Adjacency . Operation . SET )  E   extends   VertexFrame   void   includeFoobar ( Iterator ?   extends   E   vertex );", 
            "title": "Signature: (Iterator)"
        }, 
        {
            "location": "/annotations/adjacency/#signature-iterable", 
            "text": "Valid return types:  void  The argument for this method must be an  Iterable  or a subclass of  Iterable  which iterates over vertex Frames. It is\nsuggested you specify a Generic Type for the Iterator for usability.  Since all Java collections inherit from the  Iterable  interface they can also be used as parameters to these methods.  This method will iterate over all the vertex specified in the  Iterable  argument and create new edges to connect to it.\nThe edges in the graph will not encode a type.  Any existing edges matching the specified label that do not connect to one of the  VertexFrame  provided by the iterator\nwill be removed.  example:  @Adjacency ( Foo )  void   setFoobar ( Iterable BarVertex   vertex );   @Adjacency ( Foo )  void   setFoobar ( Collection BarVertex   vertex );   @Adjacency ( Foo )  void   setFoobar ( List BarVertex   vertex );   @Adjacency ( Foo )  void   setFoobar ( Set BarVertex   vertex );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   BarVertex   void   setFoobar ( Iterable ?   extends   E   vertex );   @Adjacency ( Foo ,   operation   =   Adjacency . Operation . SET )  E   extends   VertexFrame   void   includeFoobar ( Iterable ?   extends   E   vertex );", 
            "title": "Signature: (Iterable)"
        }, 
        {
            "location": "/annotations/graphelement/", 
            "text": "Valid on frames: \nEdge\n and \nvertex\n\n\nThe \n@GraphElement\n annotation takes no parameters and is placed before your class decleration on an \nEdgeFrame\n or\n\nVertexFrame\n. This annotation is mostly leveraged right now when scanning classes in a package to identify frames.\n\n\nexample:\n\n\n@GraphElement\n\n\npublic\n \ninterface\n \nFooVertex\n \nextends\n \nVertexFrame\n \n{\n\n    \n//Methods goes here\n\n\n}", 
            "title": "@GraphElement"
        }, 
        {
            "location": "/annotations/incidence/", 
            "text": "Valid on frames: \nVertex\n\n\nAllowed prefixes when operation is AUTO: \nadd\n, \nget\n, \nremove\n\n\nAnnotation arguments:\n\n\nlabel\n - The label assigned to the edge which connects the adjacent nodes.\n\n\ndirection\n - The direction for the edge which creates the adjacency. It can be assigned any of the values from\n              \norg.apache.tinkerpop.gremlin.structure.Direction\n.\n\n\noperation\n - The operation the method will perform. Must be one of the following: \nGET\n, \nADD\n, \nSET\n, \nREMOVE\n,\n              \nAUTO\n. Defaults to \nAUTO\n.\n\n\nexample:\n\n\n@Incidence\n(\nfoo\n)\n\n\n//Method declared here\n\n\n\n\n\nADD Operation\n\n\nValid method signatures: \n( )\n, \n(VertexFrame)\n, \n(ClassInitializer)\n, \n(VertexFrame, ClassInitializer)\n,\n\n(ClassInitializer, ClassInitializer)\n\n\nAdds an edge to edge to a node and returns the new \nEdgeFrame\n.\n\n\nSignature: \n( )\n\n\nValid return types: \nEdgeFrame\n\n\nCreates a new vertex without any type information as well as an untyped edge to connect to it. The newly created\n\nTEdge\n is returned.\n\n\n\n\nNote\n\n\nSince the returned \nVertexFrame\n is always untyped the return type must be either \nVertexFrame\n or \nTVertex\n\nspecifically.\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nEdgeFrame\n \naddFoobar\n();\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nTEdge\n \naddFoobar\n();\n\n\n\n\n\nSignature: \n(VertexFrame)\n\n\nValid return types: \nEdgeFrame\n\n\nCreates a new edge without any type information and connects it between this vertex the vertex specified as an argument\nto the method. The frame returned is the newly created \nTEdge\n.\n\n\nexamples:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \naddFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \naddFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nEdgeFrame\n \naddFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nE\n \naddFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nFooEdge\n \nincludeFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\nSignature: \n(ClassInitializer)\n\n\nValid return types: \nEdgeFrame\n\n\nCreates a new edge without any type information and connects it between this vertex and a newly created vertex. The\nnewly created vertex will have a type, as well as be initiated, according to the details specified in the\nClassInitializer argument. Java generics can, and should, be used to narrow the return type. The returned object will be\nthe newly created \nTEdge\n.\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nFooEdge\n \nvertexInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nTEdge\n \nincludeFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n);\n\n\n\n\n\nSignature: \n(VertexFrame, ClassInitializer)\n\n\nValid return types: \nEdgeFrame\n\n\nCreates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be\ninitiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type. The returned object will be the newly created \nEdgeFrame\n.\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \naddFoobar\n(\nBarVertex\n \nbar\n,\n\n                  \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \naddFoobar\n(\nBarVertex\n \nbar\n,\n\n                                \nClassInitializer\n?\n \nextends\n \nE\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nE\n \naddFoobar\n(\nVertexFrame\n \nvertex\n,\n\n                                  \nClassInitializer\n?\n \nextends\n \nE\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nFooEdge\n \nincludeFoobar\n(\nBarVertex\n \nbar\n,\n\n                      \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\nSignature: \n(ClassInitializer, ClassInitializer)\n\n\nValid return types: \nEdgeFrame\n\n\nCreates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be\ninitiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge\nwill hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type. The returned object will be the newly created \nEdgeFrame\n.\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                    \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                                  \nClassInitializer\n?\n \nextends\n \nE\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                                  \nClassInitializer\n?\n \nextends\n \nE\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nFooEdge\n \nincludeFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                      \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\nGET Operation\n\n\nValid method signatures: \n()\n, \n(Class)\n\n\nGet's one or more adjacent edgesd from the graph.\n\n\nSignature: \n( )\n\n\nValid return types: \nVertexFrame\n or \nIterator\n or \nList\n or \nSet\n\n\nRetrieves one or more of the adjacent vertex. If the return type is a single Frame then only the first instance is\nreturned. If the return type is an \nIterator\n or \nList\n or \nSet\n then it will supply all matching edges. When using an\n\nIterator\n or \nList\n or \nSet\n it is encouraged, but not required, to use generics. The returned frames will always be\ninstantiated as the type encoded in the graph if there is one.\n\n\n\n\nNote\n\n\nIf a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown.\nTherefore the return type specifed should always by the same type, or a superclass, of the expected return type.\nVertexFrame is always a safe return type for this method.\n\n\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nIterator\nFooEdge\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nIterator\nE\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nIterator\nE\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nList\nFooEdge\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nSet\nFooEdge\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nGET\n)\n\n\nFooEdge\n \nobtainFoobar\n();\n\n\n\n\n\nSignature: \n(Class)\n\n\nValid return types: \nVertexFrame\n or \nIterator\n or \nList\n or \nSet\n\n\nRetrieves one or more of the adjacent edges. If the return type is a single \nEdgeFrame\n then only the first instance\nis returned. If the return type is an \nIterator\n then it will iterate over all matching vertex. When using an Iterator\nit is encouraged to use generics.\n\n\n\n\nNote\n\n\nThe Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype,\nto that of the argument will be returned.\n\n\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nFooEdge\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nIterator\nFooEdge\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nFooEdge\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nIterator\nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nIterator\nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nList\nFooEdge\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nFooEdge\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nSet\nFooEdge\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nFooEdge\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nGET\n)\n\n\nFooEdge\n \nobtainFoobar\n(\nClass\n?\n \nextends\n \nFooEdge\n \nfilter\n);\n\n\n\n\n\nREMOVE Operation\n\n\nValid method signatures: \n(EdgeFrame)\n\n\nRemoves an edges which cause an adjacency, leaving the vertex in place.\n\n\nSignature: \n(EdgeFrame)\n\n\nValid return types: \nvoid\n\n\nRemoves the edge specified in the argument. This is entirely equivelant to just calling the \nremove()\n method on the\n\nEdgeFrame\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nvoid\n \nremoveFoobar\n(\nFooEdge\n \nedge\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nvoid\n \nremoveFoobar\n(\nE\n \nedge\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nvoid\n \nremoveFoobar\n(\nE\n \nedge\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nREMOVE\n)\n\n\nvoid\n \nremoveFoobar\n(\nFooEdge\n \nedge\n);", 
            "title": "@Incidence"
        }, 
        {
            "location": "/annotations/incidence/#add-operation", 
            "text": "Valid method signatures:  ( ) ,  (VertexFrame) ,  (ClassInitializer) ,  (VertexFrame, ClassInitializer) , (ClassInitializer, ClassInitializer)  Adds an edge to edge to a node and returns the new  EdgeFrame .", 
            "title": "ADD Operation"
        }, 
        {
            "location": "/annotations/incidence/#signature", 
            "text": "Valid return types:  EdgeFrame  Creates a new vertex without any type information as well as an untyped edge to connect to it. The newly created TEdge  is returned.   Note  Since the returned  VertexFrame  is always untyped the return type must be either  VertexFrame  or  TVertex \nspecifically.   @Incidence ( Foo )  EdgeFrame   addFoobar ();   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  TEdge   addFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/incidence/#signature-vertexframe", 
            "text": "Valid return types:  EdgeFrame  Creates a new edge without any type information and connects it between this vertex the vertex specified as an argument\nto the method. The frame returned is the newly created  TEdge .  examples:  @Incidence ( Foo )  FooEdge   addFoobar ( BarVertex   existingVertex );   @Incidence ( Foo )  E   extends   FooEdge   E   addFoobar ( BarVertex   existingVertex );   @Incidence ( Foo )  EdgeFrame   addFoobar ( BarVertex   existingVertex );   @Incidence ( Foo ,   direction   =   Direction . IN )  E   extends   EdgeFrame   E   addFoobar ( BarVertex   existingVertex );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  FooEdge   includeFoobar ( BarVertex   existingVertex );", 
            "title": "Signature: (VertexFrame)"
        }, 
        {
            "location": "/annotations/incidence/#signature-classinitializer", 
            "text": "Valid return types:  EdgeFrame  Creates a new edge without any type information and connects it between this vertex and a newly created vertex. The\nnewly created vertex will have a type, as well as be initiated, according to the details specified in the\nClassInitializer argument. Java generics can, and should, be used to narrow the return type. The returned object will be\nthe newly created  TEdge .  example:  @Incidence ( Foo )  FooEdge   addFoobar ( ClassInitializer ?   extends   FooEdge   vertexInitializer );   @Incidence ( Foo )  E   extends   FooEdge   E   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer );   @Incidence ( Foo ,   direction   =   Direction . IN )  E   extends   FooEdge   E   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  TEdge   includeFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer );", 
            "title": "Signature: (ClassInitializer)"
        }, 
        {
            "location": "/annotations/incidence/#signature-vertexframe-classinitializer", 
            "text": "Valid return types:  EdgeFrame  Creates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be\ninitiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type. The returned object will be the newly created  EdgeFrame .  example:  @Incidence ( Foo )  FooEdge   addFoobar ( BarVertex   bar , \n                   ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Incidence ( Foo )  E   extends   FooEdge   E   addFoobar ( BarVertex   bar , \n                                 ClassInitializer ?   extends   E   edgeInitializer );   @Incidence ( Foo ,   direction   =   Direction . IN )  E   extends   EdgeFrame   E   addFoobar ( VertexFrame   vertex , \n                                   ClassInitializer ?   extends   E   edgeInitializer );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  FooEdge   includeFoobar ( BarVertex   bar , \n                       ClassInitializer ?   extends   FooEdge   edgeInitializer );", 
            "title": "Signature: (VertexFrame, ClassInitializer)"
        }, 
        {
            "location": "/annotations/incidence/#signature-classinitializer-classinitializer", 
            "text": "Valid return types:  EdgeFrame  Creates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be\ninitiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge\nwill hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type. The returned object will be the newly created  EdgeFrame .  example:  @Incidence ( Foo )  FooEdge   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                     ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Incidence ( Foo )  E   extends   FooEdge   E   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                                   ClassInitializer ?   extends   E   edgeInitializer );   @Incidence ( Foo ,   direction   =   Direction . IN )  E   extends   EdgeFrame   E   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                                   ClassInitializer ?   extends   E   edgeInitializer );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  FooEdge   includeFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                       ClassInitializer ?   extends   FooEdge   edgeInitializer );", 
            "title": "Signature: (ClassInitializer, ClassInitializer)"
        }, 
        {
            "location": "/annotations/incidence/#get-operation", 
            "text": "Valid method signatures:  () ,  (Class)  Get's one or more adjacent edgesd from the graph.", 
            "title": "GET Operation"
        }, 
        {
            "location": "/annotations/incidence/#signature_1", 
            "text": "Valid return types:  VertexFrame  or  Iterator  or  List  or  Set  Retrieves one or more of the adjacent vertex. If the return type is a single Frame then only the first instance is\nreturned. If the return type is an  Iterator  or  List  or  Set  then it will supply all matching edges. When using an Iterator  or  List  or  Set  it is encouraged, but not required, to use generics. The returned frames will always be\ninstantiated as the type encoded in the graph if there is one.   Note  If a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown.\nTherefore the return type specifed should always by the same type, or a superclass, of the expected return type.\nVertexFrame is always a safe return type for this method.   example:  @Incidence ( Foo )  FooEdge   getFoobar ();   @Incidence ( Foo )  E   extends   FooEdge   E   getFoobar ();   @Incidence ( Foo )  E   extends   EdgeFrame   E   getFoobar ();   @Incidence ( Foo )  Iterator FooEdge   getFoobar ();   @Incidence ( Foo )  E   extends   FooEdge   Iterator E   getFoobar ();   @Incidence ( Foo )  E   extends   EdgeFrame   Iterator E   getFoobar ();   @Incidence ( Foo )  List FooEdge   getFoobar ();   @Incidence ( Foo ,   direction   =   Direction . IN )  Set FooEdge   getFoobar ();   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . GET )  FooEdge   obtainFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/incidence/#signature-class", 
            "text": "Valid return types:  VertexFrame  or  Iterator  or  List  or  Set  Retrieves one or more of the adjacent edges. If the return type is a single  EdgeFrame  then only the first instance\nis returned. If the return type is an  Iterator  then it will iterate over all matching vertex. When using an Iterator\nit is encouraged to use generics.   Note  The Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype,\nto that of the argument will be returned.   example:  @Incidence ( Foo )  FooEdge   getFoobar ( Class ?   extends   FooEdge   filter );   @Incidence ( Foo )  E   extends   FooEdge   E   getFoobar ( Class ?   extends   E   filter );   @Incidence ( Foo )  E   extends   FooEdge   E   getFoobar ( Class ?   extends   E   filter );   @Incidence ( Foo )  Iterator FooEdge   getFoobar ( Class ?   extends   FooEdge   filter );   @Incidence ( Foo )  E   extends   FooEdge   Iterator E   getFoobar ( Class ?   extends   E   filter );   @Incidence ( Foo )  E   extends   EdgeFrame   Iterator E   getFoobar ( Class ?   extends   E   filter );   @Incidence ( Foo )  List FooEdge   getFoobar ( Class ?   extends   FooEdge   filter );   @Incidence ( Foo ,   direction   =   Direction . IN )  Set FooEdge   getFoobar ( Class ?   extends   FooEdge   filter );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . GET )  FooEdge   obtainFoobar ( Class ?   extends   FooEdge   filter );", 
            "title": "Signature: (Class)"
        }, 
        {
            "location": "/annotations/incidence/#remove-operation", 
            "text": "Valid method signatures:  (EdgeFrame)  Removes an edges which cause an adjacency, leaving the vertex in place.", 
            "title": "REMOVE Operation"
        }, 
        {
            "location": "/annotations/incidence/#signature-edgeframe", 
            "text": "Valid return types:  void  Removes the edge specified in the argument. This is entirely equivelant to just calling the  remove()  method on the EdgeFrame  example:  @Incidence ( Foo )  void   removeFoobar ( FooEdge   edge );   @Incidence ( Foo )  E   extends   FooEdge   void   removeFoobar ( E   edge );   @Incidence ( Foo ,   direction   =   Direction . IN )  E   extends   EdgeFrame   void   removeFoobar ( E   edge );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . REMOVE )  void   removeFoobar ( FooEdge   edge );", 
            "title": "Signature: (EdgeFrame)"
        }, 
        {
            "location": "/annotations/invertex/", 
            "text": "Valid on frames: \nEdge\n\n\nAllowed prefixes when operation is AUTO: \nget\n\n\nThe \n@InVertex\n takes no parameters and is used only on get methods that themself take no parameters. It specifies the\n\nVertexFrame\n at the head of an edge.\n\n\nexample:\n\n\n@InVertex\n\n\n//Method declared here\n\n\n\n\n\nGET Operation\n\n\nValid method signatures: \n( )\n\n\nSignature: \n( )\n\n\nValid return types: \nVertexFrame\n.\n\n\nGet the head vertex of the edge.\n\n\nexample:\n\n\n@InVertex\n\n\nBarVertex\n \ngetFoobar\n();", 
            "title": "@InVertex"
        }, 
        {
            "location": "/annotations/invertex/#get-operation", 
            "text": "Valid method signatures:  ( )", 
            "title": "GET Operation"
        }, 
        {
            "location": "/annotations/invertex/#signature", 
            "text": "Valid return types:  VertexFrame .  Get the head vertex of the edge.  example:  @InVertex  BarVertex   getFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/outvertex/", 
            "text": "Valid on frames: \nEdge\n\n\nAllowed prefixes when operation is AUTO: \nget\n\n\nThe \n@OutVertex\n takes no parameters and is used only on get methods that themself take no parameters. It specifies the\n\nVertexFrame\n at the tail of an edge.\n\n\nexample:\n\n\n@OutVertex\n\n\n//Method declared here\n\n\n\n\n\nGET Operation\n\n\nValid method signatures: \n( )\n\n\nSignature: \n( )\n\n\nValid return types: \nVertexFrame\n.\n\n\nGet the tail vertex of the edge.\n\n\nexample:\n\n\n@OutVertex\n\n\nBarVertex\n \ngetFoobar\n();", 
            "title": "@OutVertex"
        }, 
        {
            "location": "/annotations/outvertex/#get-operation", 
            "text": "Valid method signatures:  ( )", 
            "title": "GET Operation"
        }, 
        {
            "location": "/annotations/outvertex/#signature", 
            "text": "Valid return types:  VertexFrame .  Get the tail vertex of the edge.  example:  @OutVertex  BarVertex   getFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/property/", 
            "text": "Valid on frames: \nEdge\n and \nVertex\n\n\nAllowed prefixes when operation is AUTO: \nget\n, \nis\n, \ncan\n, \nset\n, \nremove\n\n\nAnnotation arguments:\n\n\nvalue\n - The name of the property\n\n\noperation\n - The operation the method will perform. Must be one of the following: \nGET\n, \nSET\n, \nREMOVE\n, \nAUTO\n.\nDefaults to \nAUTO\n.\n\n\nThe following would bind the method it is used on to the property named \nfoo\n:\n\n\n@Property\n(\nfoo\n)\n\n\n//Method declared here\n\n\n\n\n\nGET Operation\n\n\nValid method signatures: \n( )\n\n\nSignature: \n( )\n\n\nValid return types: \nObject\n or any primitive.\n\n\nGet the property value of an element. Used when property is not a boolean value.\n\n\nexample:\n\n\n@Property\n(\nFoo\n)\n\n\nBar\n \ngetFoobar\n();\n\n\n\n\n\n@Property\n(\nFoo\n)\n\n\nE\n \nextends\n \nBar\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Property\n(\nFoo\n)\n\n\nE\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Property\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nProperty\n.\nOperation\n.\nGET\n)\n\n\nBar\n \nobtainFoobar\n();\n\n\n\n\n\nGET Operation (is prefix)\n\n\nValid method signatures: \n( )\n\n\nSignature: \n( )\n\n\nValid return types: \nboolean\n\n\nGet the property value of an element. Used when property is a boolean value.\n\n\nexample:\n\n\n@Property\n(\nFoobared\n)\n\n\nboolean\n \nisFoobared\n();\n\n\n\n\n\n@Property\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nProperty\n.\nOperation\n.\nGET\n)\n\n\nboolean\n \nobtainFoobared\n();\n\n\n\n\n\nSET Operation\n\n\nValid method signatures: \n(Object)\n\n\nSignature: \n(Object)\n\n\nValid return types: \nvoid\n\n\nSet the property value of an element. The argument can be any class accepted by the underlying graph.\n\n\nexample:\n\n\n@Property\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nBar\n \nfoobar\n);\n\n\n\n\n\n@Property\n(\nFoo\n)\n\n\nE\n \nextends\n \nBar\n \nvoid\n \nsetFoobar\n(\nE\n \nfoobar\n);\n\n\n\n\n\n@Property\n(\nFoo\n)\n\n\nE\n \nextends\n \nVectorFrame\n \nvoid\n \nsetFoobar\n(\nE\n \nfoobar\n);\n\n\n\n\n\n@Property\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nBar\n \nfoobar\n);\n\n\n\n\n\n@Property\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nProperty\n.\nOperation\n.\nSET\n)\n\n\nvoid\n \napplyFoobar\n(\nBar\n \nfoobar\n);\n\n\n\n\n\nREMOVE Operation\n\n\nValid method signatures: \n( )\n\n\nSignature: \n( )\n\n\nValid return types: \nvoid\n\n\nRemove the property of an element.\n\n\nexample:\n\n\n@Property\n(\nFoo\n)\n\n\nvoid\n \nremoveFoobar\n();\n\n\n\n\n\n@Property\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nProperty\n.\nOperation\n.\nREMOVE\n)\n\n\nvoid\n \nremoveFoobar\n();", 
            "title": "@Property"
        }, 
        {
            "location": "/annotations/property/#get-operation", 
            "text": "Valid method signatures:  ( )", 
            "title": "GET Operation"
        }, 
        {
            "location": "/annotations/property/#signature", 
            "text": "Valid return types:  Object  or any primitive.  Get the property value of an element. Used when property is not a boolean value.  example:  @Property ( Foo )  Bar   getFoobar ();   @Property ( Foo )  E   extends   Bar   E   getFoobar ();   @Property ( Foo )  E   E   getFoobar ();   @Property ( value   =   Foo ,   operation   =   Property . Operation . GET )  Bar   obtainFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/property/#get-operation-is-prefix", 
            "text": "Valid method signatures:  ( )", 
            "title": "GET Operation (is prefix)"
        }, 
        {
            "location": "/annotations/property/#signature_1", 
            "text": "Valid return types:  boolean  Get the property value of an element. Used when property is a boolean value.  example:  @Property ( Foobared )  boolean   isFoobared ();   @Property ( value   =   Foo ,   operation   =   Property . Operation . GET )  boolean   obtainFoobared ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/property/#set-operation", 
            "text": "Valid method signatures:  (Object)", 
            "title": "SET Operation"
        }, 
        {
            "location": "/annotations/property/#signature-object", 
            "text": "Valid return types:  void  Set the property value of an element. The argument can be any class accepted by the underlying graph.  example:  @Property ( Foo )  void   setFoobar ( Bar   foobar );   @Property ( Foo )  E   extends   Bar   void   setFoobar ( E   foobar );   @Property ( Foo )  E   extends   VectorFrame   void   setFoobar ( E   foobar );   @Property ( Foo )  void   setFoobar ( Bar   foobar );   @Property ( value   =   Foo ,   operation   =   Property . Operation . SET )  void   applyFoobar ( Bar   foobar );", 
            "title": "Signature: (Object)"
        }, 
        {
            "location": "/annotations/property/#remove-operation", 
            "text": "Valid method signatures:  ( )", 
            "title": "REMOVE Operation"
        }, 
        {
            "location": "/annotations/property/#signature_2", 
            "text": "Valid return types:  void  Remove the property of an element.  example:  @Property ( Foo )  void   removeFoobar ();   @Property ( value   =   Foo ,   operation   =   Property . Operation . REMOVE )  void   removeFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/glossary/", 
            "text": "Frame\n - A class from the schema that represents an element from the graph. A frame usually extends either a\n            VertexFrame or an EdgeFrame, though they are not required to do so.\n\n\nElement\n - Either a vertex or an edge in a graph.", 
            "title": "Glossary"
        }
    ]
}