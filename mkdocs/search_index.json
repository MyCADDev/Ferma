{
    "docs": [
        {
            "location": "/",
            "text": "An ORM / OGM for the TinkerPop graph stack.\n\n\nLicensed under the Apache Software License v2\n\n\nThe Ferma project was originally created as an alternative to the\nTinkerPop2 Frames project. Which at the time lacked features needed by\nthe community, and its performance was cripplingly slow. Today Ferma is\na robust framework that takes on a role similar to an Object-relational\nModel (ORM) library for traditional databases. Ferma is often referred\nto as a Object-graph Model (OGM) library, and maps Java objects to\nelements in a graph such as a Vertex or an Edges. In short it allows a\nschema to be defined using java interfaces and classes which provides a\nlevel of abstraction for interacting with the underlying graph.\n\n\nFerma 3.x \nSupports TinkerPop3\n. For tinkerPop2 support use Ferma\nversion 2.x.\n\n\nAnnotated classes in Ferma have their abstract methods implemented using\ncode generation during start-up with Byte Buddy, avoiding the need for\nproxy classes. This in turn significantly improves performance when\ncompared with TinkerPop Frames and other frameworks. Ferma offers many\nfeatures including several annotation types to reduce the need for\nboilerplate code as well as handling Java typing transparently. This\nensures whatever the type of the object is when you persist it to the\ngraph the same Java type will be used when instantiating a class off of\nthe graph.\n\n\nFerma is designed to easily replace TinkerPop Frames in existing code,\nas such, the annotations provided by Ferma are a super-set of those\nprovided by TinkerPop Frames.\n\n\nFerma is built directly on top of TinkerPop and allows access to all of\nthe internals. This ensures all the TinkerPop features are available to\nthe end-user. The TinkerPop stack provides several tools which can be\nused to work with the Ferma engine.\n\n\n\n\nGremlin\n, a database agnostic query language for Graph Databases.\n\n\nGremlin Server\n, a server that provides an interface for\n    executing Gremlin on remote machines.\n\n\na data-flow framework for splitting, merging, filtering, and\n    transforming of data\n\n\nGraph Computer\n, a framework for running algorithms against a\n    Graph Database.\n\n\nSupport for both \nOLTP\n and \nOLAP\n engines.\n\n\nTinkerGraph\n a Graph Database and the reference implementation\n    for TinkerPop.\n\n\nNative \nGephi\n integration for visualizing graphs.\n\n\nInterfaces for most major Graph Compute Engines including \nHadoop\n    M/R\n. \nSpark\n, and \nGiraph\n.\n\n\n\n\nFerma also supports any of the many databases compatible with TinkerPop\nincluding the following.\n\n\n\n\nTitan\n\n\nNeo4j\n\n\nOrientDB\n\n\nMongoDB\n\n\nOracle\n    NoSQL\n\n\nTinkerGraph\n\n\n\n\nFerma Javadocs:\n\nlatest\n -\n\n3.0.1\n -\n\n3.0.0\n -\n\n2.2.0\n -\n\n2.1.0\n -\n\n2.0.6\n -\n\n2.0.5\n -\n\n2.0.4\n -\n\n2.0.3\n -\n\n2.0.2\n -\n\n2.0.1\n -\n\n2.0.0\n\n\nFor support please use\n\nGitter\n\nor the \nofficial Ferma mailing\nlist\n.\n\n\nPlease file bugs and feature requests on\n\nGithub\n.\n\n\nObtaining the Source\n\u00b6\n\n\nThe official source repository for Ferma is located in the Syncleus\nGithub repository and can be cloned using the following command.\n\n\ngit clone https://github.com/Syncleus/Ferma.git",
            "title": "Home"
        },
        {
            "location": "/#obtaining-the-source",
            "text": "The official source repository for Ferma is located in the Syncleus\nGithub repository and can be cloned using the following command.  git clone https://github.com/Syncleus/Ferma.git",
            "title": "Obtaining the Source"
        },
        {
            "location": "/comparing_the_alternatives/",
            "text": "There are several OGM/ORM options out there. For the purposes of this document we will focus only on those that have a stable release, or are close to a stable release. At the time of this writing those are: Tinkerpop Framed and Totorom.\n\n\nBenchmarks\n\u00b6\n\n\nWe maintain an informal project for benchmarking Ferma against other OGM available, you can find the \nsource here\n. However below is a matrix breakdown of the results. Instead of showing raw execution time we show the ratio of each OGM compared to Ferma. Therefore if the table lists 1x then it means the framework has the same execution time as Ferma, if it lists 2x then it took twice as long to execute, and if it indicates 0.5x then it took half the time to execute. Obviously any value less than 1x indicates the OGM out performed Ferma and any value greater than 1x indicates Ferma had the superior performance tiimes.\n\n\n\n\n\n\n\n\n\n\nBlueprints\n\n\nGremlin Pipeline\n\n\nTinkerpop3\n\n\nFrames\n\n\nTotorom\n\n\nPeapod\n\n\n\n\n\n\n\n\n\n\nGet adjacencies via annotation\n\n\nNot capable\n\n\nNot capable\n\n\nNot capable\n\n\nx2.09\n\n\nNot capable\n\n\nx2.65\n\n\n\n\n\n\nGet verticies (untyped)\n\n\nx0.89\n\n\nx3.94\n\n\nx16.98\n\n\nNot capable\n\n\nx4.24\n\n\nNot capable\n\n\n\n\n\n\nGet verticies (typed)\n\n\nx0.92\n\n\nx3.94\n\n\nNot capable\n\n\nx0.96\n\n\nx4.20\n\n\nx20.74\n\n\n\n\n\n\nGet verticies and call next (untyped)\n\n\nx0.79\n\n\nx3.87\n\n\nx11.74\n\n\nNot capable\n\n\nx4.81\n\n\nNot capable\n\n\n\n\n\n\nGet verticies and call next (typed)\n\n\nx0.72\n\n\nx2.91\n\n\nNot capable\n\n\nx1.94\n\n\nx3.31\n\n\nx16.70\n\n\n\n\n\n\n\n\nAs can be seen Ferma out performs all the alternative solutions considerably by several orders of magnitude. While results do vary slightly from system to system these results are pretty close to typical. Go ahead, check out the benchmark program and run it for yourself!\n\n\nFeature Breakdown\n\u00b6\n\n\nDespite the superior performance of Ferma it also supports all the features provided by the alternatives out there, not to mention several novel features. The following gives a quick breakdown of the features of the various frameworks. We also include a bit later in the document some Ferma examples showing the various features in action. All of the examples below use the domain model \nfound here\n.\n\n\n\n\n\n\n\n\n\n\nFerma\n\n\nFrames\n\n\nTotorom\n\n\nPeapod\n\n\n\n\n\n\n\n\n\n\nJPA-like Annotations\n\n\nSupported\n\n\nSupported\n\n\nNot Supported\n\n\nSupported\n\n\n\n\n\n\nType information encoded into graph\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\n\n\n\n\nFraming of elements instantiated according to type hierarchy\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\n\n\n\n\nElement queried by type hierarchy\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nPartial *\n\n\n\n\n\n\nTurning off type resolution on a per call basis\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nNot Supported\n\n\n\n\n\n\nChanging the encoded graph type already stored in the database\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nNot Supported\n\n\n\n\n\n\nCustomizing the way type information is stored in the graph\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nNot Supported\n\n\n\n\n\n\nTinkerpop 2 support\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\nNot Supported\n\n\n\n\n\n\nTinkerpop 3 support\n\n\nNot Supported\n\n\nNot Supported\n\n\nNot Supported\n\n\nSupported\n\n\n\n\n\n\n\n\n* While Peapod does support querying for all instances of a type, and its subtypes, it does not support a mechanism to query for a specific type while excluding subtypes.\n\n\nType information encoded into graph\n\u00b6\n\n\nSet<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class}));\nGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, types);\n\nfg.addFramedVertex(Person.class);\nPerson person = fg.v().next(Program.class);\n\nString personClassName = Person.class.getName();\nString encodedClassName = person.getProperty(PolymorphicTypeResolver.TYPE_RESOLUTION_KEY)\nassert(personClassName.equals(encodedClassName));\n\n\n\n\nFraming instantiated by type hierarchy\n\u00b6\n\n\nSet<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class,\n                                                                         Programmer.class}));\nTinkerGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, types);\n\nfg.addFramedVertex(Programmer.class);\n\n//make sure the newly added node is actually a programmer\nPerson programmer = fg.v().next(Person.class);\nassert(programmer instanceof Programmer);\n\n\n\n\nElement queried by type hierarchy\n\u00b6\n\n\nSet<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class,\n                                                                         Programmer.class}));\nTinkerGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, types);\n\nfg.addFramedVertex(Programmer.class);\nfg.addFramedVertex(Person.class);\n\n//counts how many people (or subclasses thereof) in the graph.\nassert(fg.v().has(Person.class).count() == 2);\n//counts how many programmers are in the graph\nassert(fg.v().has(Programmer.class).count() == 1);\n\n\n\n\nTurning off type resolution per call\n\u00b6\n\n\nSet<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class,\n                                                                         Programmer.class}));\nTinkerGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, types);\n\nfg.addFramedVertex(Programmer.class);\n\n//With type resolution is active it should be a programmer\nassert(fg.v().next(Person.class) instanceof Programmer);\n//With type resolution bypassed it is no longer a programmer\nassert(!(fg.v().nextExplicit(Person.class) instanceof Programmer));\n\n\n\n\nChanging type encoded in the graph\n\u00b6\n\n\nSet<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class,\n                                                                         Programmer.class}));\nTinkerGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, types);\n\nfg.addFramedVertex(Programmer.class);\n\n//make sure the newly added node is actually a programmer\nPerson programmer = fg.v().next(Person.class);\nassert(programmer instanceof Programmer);\n\n//change the type resolution to person\nprogrammer.setTypeResolution(Person.class);\n\n//make sure the newly added node is actually a programmer\nPerson person = fg.v().next(Person.class);\nassert(person instanceof Person);\nassert(!(person instanceof Programmer));\n\n\n\n\nCustomizing how types are encoded\n\u00b6\n\n\nSet<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class}));\nfinal ReflectionCache cache = new ReflectionCache(types);\nFrameFactory factory = new AnnotationFrameFactory(cache);\nTypeResolver resolver = new PolymorphicTypeResolver(cache, \"customTypeKey\");\nGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, factory, resolver);\n\nfg.addFramedVertex(Person.class);\nPerson person = fg.v().next(Program.class);\n\nString personClassName = Person.class.getName();\nString encodedClassName = person.getProperty(\"customTypeKey\")\nassert(personClassName.equals(encodedClassName));",
            "title": "Comparing the Alternatives"
        },
        {
            "location": "/comparing_the_alternatives/#benchmarks",
            "text": "We maintain an informal project for benchmarking Ferma against other OGM available, you can find the  source here . However below is a matrix breakdown of the results. Instead of showing raw execution time we show the ratio of each OGM compared to Ferma. Therefore if the table lists 1x then it means the framework has the same execution time as Ferma, if it lists 2x then it took twice as long to execute, and if it indicates 0.5x then it took half the time to execute. Obviously any value less than 1x indicates the OGM out performed Ferma and any value greater than 1x indicates Ferma had the superior performance tiimes.      Blueprints  Gremlin Pipeline  Tinkerpop3  Frames  Totorom  Peapod      Get adjacencies via annotation  Not capable  Not capable  Not capable  x2.09  Not capable  x2.65    Get verticies (untyped)  x0.89  x3.94  x16.98  Not capable  x4.24  Not capable    Get verticies (typed)  x0.92  x3.94  Not capable  x0.96  x4.20  x20.74    Get verticies and call next (untyped)  x0.79  x3.87  x11.74  Not capable  x4.81  Not capable    Get verticies and call next (typed)  x0.72  x2.91  Not capable  x1.94  x3.31  x16.70     As can be seen Ferma out performs all the alternative solutions considerably by several orders of magnitude. While results do vary slightly from system to system these results are pretty close to typical. Go ahead, check out the benchmark program and run it for yourself!",
            "title": "Benchmarks"
        },
        {
            "location": "/comparing_the_alternatives/#feature-breakdown",
            "text": "Despite the superior performance of Ferma it also supports all the features provided by the alternatives out there, not to mention several novel features. The following gives a quick breakdown of the features of the various frameworks. We also include a bit later in the document some Ferma examples showing the various features in action. All of the examples below use the domain model  found here .      Ferma  Frames  Totorom  Peapod      JPA-like Annotations  Supported  Supported  Not Supported  Supported    Type information encoded into graph  Supported  Supported  Supported  Supported    Framing of elements instantiated according to type hierarchy  Supported  Supported  Supported  Supported    Element queried by type hierarchy  Supported  Not Supported  Not Supported  Partial *    Turning off type resolution on a per call basis  Supported  Not Supported  Not Supported  Not Supported    Changing the encoded graph type already stored in the database  Supported  Not Supported  Not Supported  Not Supported    Customizing the way type information is stored in the graph  Supported  Not Supported  Not Supported  Not Supported    Tinkerpop 2 support  Supported  Supported  Supported  Not Supported    Tinkerpop 3 support  Not Supported  Not Supported  Not Supported  Supported     * While Peapod does support querying for all instances of a type, and its subtypes, it does not support a mechanism to query for a specific type while excluding subtypes.",
            "title": "Feature Breakdown"
        },
        {
            "location": "/comparing_the_alternatives/#type-information-encoded-into-graph",
            "text": "Set<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class}));\nGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, types);\n\nfg.addFramedVertex(Person.class);\nPerson person = fg.v().next(Program.class);\n\nString personClassName = Person.class.getName();\nString encodedClassName = person.getProperty(PolymorphicTypeResolver.TYPE_RESOLUTION_KEY)\nassert(personClassName.equals(encodedClassName));",
            "title": "Type information encoded into graph"
        },
        {
            "location": "/comparing_the_alternatives/#framing-instantiated-by-type-hierarchy",
            "text": "Set<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class,\n                                                                         Programmer.class}));\nTinkerGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, types);\n\nfg.addFramedVertex(Programmer.class);\n\n//make sure the newly added node is actually a programmer\nPerson programmer = fg.v().next(Person.class);\nassert(programmer instanceof Programmer);",
            "title": "Framing instantiated by type hierarchy"
        },
        {
            "location": "/comparing_the_alternatives/#element-queried-by-type-hierarchy",
            "text": "Set<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class,\n                                                                         Programmer.class}));\nTinkerGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, types);\n\nfg.addFramedVertex(Programmer.class);\nfg.addFramedVertex(Person.class);\n\n//counts how many people (or subclasses thereof) in the graph.\nassert(fg.v().has(Person.class).count() == 2);\n//counts how many programmers are in the graph\nassert(fg.v().has(Programmer.class).count() == 1);",
            "title": "Element queried by type hierarchy"
        },
        {
            "location": "/comparing_the_alternatives/#turning-off-type-resolution-per-call",
            "text": "Set<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class,\n                                                                         Programmer.class}));\nTinkerGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, types);\n\nfg.addFramedVertex(Programmer.class);\n\n//With type resolution is active it should be a programmer\nassert(fg.v().next(Person.class) instanceof Programmer);\n//With type resolution bypassed it is no longer a programmer\nassert(!(fg.v().nextExplicit(Person.class) instanceof Programmer));",
            "title": "Turning off type resolution per call"
        },
        {
            "location": "/comparing_the_alternatives/#changing-type-encoded-in-the-graph",
            "text": "Set<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class,\n                                                                         Programmer.class}));\nTinkerGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, types);\n\nfg.addFramedVertex(Programmer.class);\n\n//make sure the newly added node is actually a programmer\nPerson programmer = fg.v().next(Person.class);\nassert(programmer instanceof Programmer);\n\n//change the type resolution to person\nprogrammer.setTypeResolution(Person.class);\n\n//make sure the newly added node is actually a programmer\nPerson person = fg.v().next(Person.class);\nassert(person instanceof Person);\nassert(!(person instanceof Programmer));",
            "title": "Changing type encoded in the graph"
        },
        {
            "location": "/comparing_the_alternatives/#customizing-how-types-are-encoded",
            "text": "Set<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{Person.class}));\nfinal ReflectionCache cache = new ReflectionCache(types);\nFrameFactory factory = new AnnotationFrameFactory(cache);\nTypeResolver resolver = new PolymorphicTypeResolver(cache, \"customTypeKey\");\nGraph g = new TinkerGraph();\nFramedGraph fg = new DelegatingFramedGraph(g, factory, resolver);\n\nfg.addFramedVertex(Person.class);\nPerson person = fg.v().next(Program.class);\n\nString personClassName = Person.class.getName();\nString encodedClassName = person.getProperty(\"customTypeKey\")\nassert(personClassName.equals(encodedClassName));",
            "title": "Customizing how types are encoded"
        },
        {
            "location": "/core_annotations/",
            "text": "Property annotation\n\n\nget prefix\n\n\n()\n\n\n\n\n\n\nis prefix\n\n\n()\n\n\n\n\n\n\nset prefix\n\n\n(Object)\n\n\n\n\n\n\nremove prefix\n\n\n()\n\n\n\n\n\n\n\n\n\n\nAdjacency annotation\n\n\nadd prefix\n\n\n()\n\n\n(<Any Vertex Frame>)\n\n\n(ClassInitializer)\n\n\n(ClassInitializer, ClassInitializer)\n\n\n\n\n\n\nget prefix\n\n\n()\n\n\n(Class)\n\n\n\n\n\n\nremove prefix\n\n\n(<Any Vertex Frame>)\n\n\n\n\n\n\nset prefix\n\n\n(Iterator)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Ferma schema is defined by a collection of interfaces and classes written by the user. Each method will interact with the underlying graph to either modify the graph in some way, or to retrieve an element or property from the graph. There are two techniques for defining how these methods behave. Either you can explicitly implement the method, or you can leave the method as abstract and annotate the method in order to allow Ferma to implement the method for you. Here we will define the annotations available to you and how they work, along with a few examples.\n\n\nThe behavior of an annotated method is dictated not only by the annotation applied to it but also the method's signature. Therefore an annotated method will behave differently if it's return type, arguments, or even if the method name were to change. It is important to note that when a method is explicitly defined (doesnt use an annotation) then the method signature can be anything.\n\n\nMethod names that are annotated must have one of the following prefixes: add, get, remove, set, is, can.\n\n\nBelow specifies that annotations that can be used when defining a Frame's interface. By specifying the method argument and return types, the underlying graph is constrained to the interface specification.\n\n\nProperty annotation\n\u00b6\n\n\nValid on frames: Edge and Vertex\n\n\nAllowed prefixes: \nget\n, \nis\n, \ncan\n, \nset\n, \nremove\n\n\nAnnotation arguments:\n\n\nvalue\n - The name of the property\n\n\nThe following would bind the method it is used on to the property named \nfoo\n:\n\n\n@Property(\"foo\")\n//Method declared here\n\n\n\n\nget prefix\n\u00b6\n\n\nValid method signatures: \n()\n\n\n()\n\u00b6\n\n\nValid return types: \nAny Object\n\n\nGet the property value of an element. Used when property is not a boolean value.\n\n\nexample:\n\n\n@Property(\"Foo\")\nBar getFoobar()\n\n\n\n\n@Property(\"Foo\")\n<E extends Bar> E getFoobar()\n\n\n\n\n@Property(\"Foo\")\n<E> E getFoobar()\n\n\n\n\nis prefix\n\u00b6\n\n\nValid method signatures: \n()\n\n\n()\n\u00b6\n\n\nValid return types: \nboolean\n\n\nGet the property value of an element. Used when property is a boolean value.\n\n\nexample:\n\n\n@Property(\"Foobared\")\nboolean isFoobared()\n\n\n\n\nset prefix\n\u00b6\n\n\nValid method signatures: \n(Object)\n\n\n(Object)\n\u00b6\n\n\nValid return types: \nvoid\n\n\nSet the property value of an element. The argument can be any class accepted by the underlying graph.\n\n\nexample:\n\n\n@Property(\"Foo\")\nvoid setFoobar(Bar foobar)\n\n\n\n\n@Property(\"Foo\")\n<E extends Bar> void setFoobar(E foobar)\n\n\n\n\n@Property(\"Foo\")\n<E extends VectorFrame> void setFoobar(E foobar)\n\n\n\n\nremove prefix\n\u00b6\n\n\nValid method signatures: \n()\n\n\n()\n\u00b6\n\n\nValid return types: \nvoid\n\n\nRemove the property of an element.\n\n\nexample:\n\n\n@Property(\"Foo\")\nvoid removeFoobar()\n\n\n\n\nAdjacency annotation\n\u00b6\n\n\nValid on frames: Vertex\n\n\nAllowed prefixes: \nadd\n, \nget\n, \nremove\n, \nset\n\n\nAnnotation arguments:\n\n\nlabel\n - The label assigned to the edge which connects the adjacent nodes.\n\n\ndirection\n - The direction for the edge which creates the adjacency. It can be assigned any of the values from @org.apache.tinkerpop.gremlin.structure.Direction@.\n\n\nadd prefix\n\u00b6\n\n\nValid method signatures: \n()\n, \n(<Any Vertex Frame>)\n, \n(ClassInitializer)\n, \n(ClassInitializer, ClassInitializer)\n\n\nAdds a node as an adjacency to the current node, and the returns the newly connected node.\n\n\n()\n\u00b6\n\n\nValid return types: \nObject\n or \nVertexFrame\n\n\nCreates a new vertex without any type information as well as an untyped edge to connect to it. The newly created VertexFrame is returned. Since it is untyped the return type of the signature can either be \nObject\n or \nVertexFrame\n.\n\n\nexample:\n\n\n@Adjacency(\"Foo\")\nVertexFrame addFoobar()\n\n\n\n\n(<Any Vertex Frame>)\n\u00b6\n\n\nValid return types: \nAny Vertex Frame\n\n\nCreates a new edge without any type information and connects it between this vertex the vertex specified as an argument to the method. The frame returned is the same as the frame given in the argument, it is only there for compatability with other add methods. This method can also have a \nvoid\n return type.\n\n\nexamples:\n\n\n@Adjacency(\"Foo\")\nBar addFoobar(Bar existingVertex)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends Bar> E addFoobar(E existingVertex)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends VertexFrame> E addFoobar(E existingVertex)\n\n\n\n\n(ClassInitializer)\n\u00b6\n\n\nValid return types: \nAny Vertex Frame\n\n\nCreates a new edge without any type information and connects it between this vertex and a newly created vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used to narrow the return type.\n\n\nexample:\n\n\n@Adjacency(\"Foo\")\nBar addFoobar(ClassInitializer<? extends Bar> vertexInitializer)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends Bar> E addFoobar(ClassInitializer<? extends E> vertexInitializer)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends VertexFrame> E addFoobar(ClassInitializer<? extends E> vertexInitializer)\n\n\n\n\n(ClassInitializer, ClassInitializer)\n\u00b6\n\n\nValid return types: \nAny Vertex Frame\n\n\nCreates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge will hava type, and be initiated using, the second ClassInitializer argument. Java generics can, and should, be used to narrow the return type.\n\n\nexample:\n\n\n@Adjacency(\"Foo\")\nBar addFoobar(ClassInitializer<? extends Bar> vertexInitializer,\n              ClassInitializer<?> edgeInitializer)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends Bar> E addFoobar(ClassInitializer<? extends E> vertexInitializer,\n                            ClassInitializer<?> edgeInitializer)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends VertexFrame> E addFoobar(ClassInitializer<? extends E> vertexInitializer,\n                                    ClassInitializer<?> edgeInitializer)\n\n\n\n\nget prefix\n\u00b6\n\n\nValid method signatures: \n()\n, \n(Class)\n\n\nGet's one or more adjacent vertex from the graph.\n\n\n()\n\u00b6\n\n\nValid return types: \nAny Vertex Frame\n or \nObject\n or \nVertexFrame\n or \nIterator\n\n\nRetrieves one or more of the adjacent vertex. If the return type is a specific Frame, an \nObject\n, or a \nVertexFrame\n then only the first instance is returned. If the return type is an iterator then it will iterate over all matching vertex. When using an Iterator it is encouraged to use generics. The returned frames will always be instantiated as the type encoded in the graph if there is one.\n\n\nNote:\n If a type is specified that is more specific than the type of the returned element then an exception will be thrown. Therefore the return type specifed should always by the same type, or a super-type, of the expected return type. VertexFrame is always a safe return type for this method.\n\n\nexample:\n\n\n@Adjacency(\"Foo\")\nBar getFoobar()\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends Bar> E getFoobar()\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends VertexFrame> E getFoobar()\n\n\n\n\n@Adjacency(\"Foo\")\nIterator<Bar> getFoobar()\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends Bar> Iterator<E> getFoobar()\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends VertexFrame> Iterator<E> getFoobar()\n\n\n\n\n(Class)\n\u00b6\n\n\nValid return types: \nAny Vertex Frame\n or \nObject\n or \nVertexFrame\n or \nIterator\n\n\nRetrieves one or more of the adjacent vertex. If the return type is a specific Frame, an \nObject\n, or a \nVertexFrame\n then only the first instance is returned. If the return type is an iterator then it will iterate over all matches vertex. When using an Iterator it is encouraged to use generics.\n\n\nThe Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype, to that of the argument will be returned.\n\n\nexample:\n\n\n@Adjacency(\"Foo\")\nBar getFoobar(Class<? extends Bar> filter)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends Bar> E getFoobar(Class<? extends E> filter)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends VertexFrame> E getFoobar(Class<? extends E> filter)\n\n\n\n\n@Adjacency(\"Foo\")\nIterator<Bar> getFoobar(Class<? extends Bar> filter)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends Bar> Iterator<E> getFoobar(Class<? extends E> filter)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends VertexFrame> Iterator<E> getFoobar(Class<? extends E> filter)\n\n\n\n\nremove prefix\n\u00b6\n\n\nValid method signatures: \n(<Any Vertex Frame>)\n\n\nRemoves any edges which cause an adjacency.\n\n\n(<Any Vertex Frame>)\n\u00b6\n\n\nValid return types: \nvoid\n\n\nRemoves any edges which create an adjacency between the vurrent vertex and the vertex specified in the methods argument.\n\n\nexample:\n\n\n@Adjacency(\"Foo\")\nvoid removeFoobar(Bar vertex)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends Bar> void removeFoobar(E vertex)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends VertexFrame> void removeFoobar(E vertex)\n\n\n\n\nset prefix\n\u00b6\n\n\nValid method signatures: \n(Iterator)\n\n\nCreates new edges connected to several vertex.\n\n\n(Iterator)\n\u00b6\n\n\nValid return types: \nvoid\n\n\nThe argument for this method must be an Iterator which iterates over any vertex Frames. It is suggested you specify a Generic Type for the Iterator for usability.\n\n\nThis method will iterate over all the vertex specified in the Iterator argument and create new edges to connect to it. The edges in the graph will not encode a type.\n\n\nexample:\n\n\n@Adjacency(\"Foo\")\nvoid setFoobar(Iterator<Bar> vertex)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends Bar> void setFoobar(Iterator<? extends E> vertex)\n\n\n\n\n@Adjacency(\"Foo\")\n<E extends VertexFrame> void setFoobar(Iterator<? extends E> vertex)",
            "title": "Core Annotations"
        },
        {
            "location": "/core_annotations/#property-annotation",
            "text": "Valid on frames: Edge and Vertex  Allowed prefixes:  get ,  is ,  can ,  set ,  remove  Annotation arguments:  value  - The name of the property  The following would bind the method it is used on to the property named  foo :  @Property(\"foo\")\n//Method declared here",
            "title": "Property annotation"
        },
        {
            "location": "/core_annotations/#get-prefix",
            "text": "Valid method signatures:  ()",
            "title": "get prefix"
        },
        {
            "location": "/core_annotations/#_1",
            "text": "Valid return types:  Any Object  Get the property value of an element. Used when property is not a boolean value.  example:  @Property(\"Foo\")\nBar getFoobar()  @Property(\"Foo\")\n<E extends Bar> E getFoobar()  @Property(\"Foo\")\n<E> E getFoobar()",
            "title": "()"
        },
        {
            "location": "/core_annotations/#is-prefix",
            "text": "Valid method signatures:  ()",
            "title": "is prefix"
        },
        {
            "location": "/core_annotations/#_2",
            "text": "Valid return types:  boolean  Get the property value of an element. Used when property is a boolean value.  example:  @Property(\"Foobared\")\nboolean isFoobared()",
            "title": "()"
        },
        {
            "location": "/core_annotations/#set-prefix",
            "text": "Valid method signatures:  (Object)",
            "title": "set prefix"
        },
        {
            "location": "/core_annotations/#object",
            "text": "Valid return types:  void  Set the property value of an element. The argument can be any class accepted by the underlying graph.  example:  @Property(\"Foo\")\nvoid setFoobar(Bar foobar)  @Property(\"Foo\")\n<E extends Bar> void setFoobar(E foobar)  @Property(\"Foo\")\n<E extends VectorFrame> void setFoobar(E foobar)",
            "title": "(Object)"
        },
        {
            "location": "/core_annotations/#remove-prefix",
            "text": "Valid method signatures:  ()",
            "title": "remove prefix"
        },
        {
            "location": "/core_annotations/#_3",
            "text": "Valid return types:  void  Remove the property of an element.  example:  @Property(\"Foo\")\nvoid removeFoobar()",
            "title": "()"
        },
        {
            "location": "/core_annotations/#adjacency-annotation",
            "text": "Valid on frames: Vertex  Allowed prefixes:  add ,  get ,  remove ,  set  Annotation arguments:  label  - The label assigned to the edge which connects the adjacent nodes.  direction  - The direction for the edge which creates the adjacency. It can be assigned any of the values from @org.apache.tinkerpop.gremlin.structure.Direction@.",
            "title": "Adjacency annotation"
        },
        {
            "location": "/core_annotations/#add-prefix",
            "text": "Valid method signatures:  () ,  (<Any Vertex Frame>) ,  (ClassInitializer) ,  (ClassInitializer, ClassInitializer)  Adds a node as an adjacency to the current node, and the returns the newly connected node.",
            "title": "add prefix"
        },
        {
            "location": "/core_annotations/#_4",
            "text": "Valid return types:  Object  or  VertexFrame  Creates a new vertex without any type information as well as an untyped edge to connect to it. The newly created VertexFrame is returned. Since it is untyped the return type of the signature can either be  Object  or  VertexFrame .  example:  @Adjacency(\"Foo\")\nVertexFrame addFoobar()",
            "title": "()"
        },
        {
            "location": "/core_annotations/#any-vertex-frame",
            "text": "Valid return types:  Any Vertex Frame  Creates a new edge without any type information and connects it between this vertex the vertex specified as an argument to the method. The frame returned is the same as the frame given in the argument, it is only there for compatability with other add methods. This method can also have a  void  return type.  examples:  @Adjacency(\"Foo\")\nBar addFoobar(Bar existingVertex)  @Adjacency(\"Foo\")\n<E extends Bar> E addFoobar(E existingVertex)  @Adjacency(\"Foo\")\n<E extends VertexFrame> E addFoobar(E existingVertex)",
            "title": "(&lt;Any Vertex Frame&gt;)"
        },
        {
            "location": "/core_annotations/#classinitializer",
            "text": "Valid return types:  Any Vertex Frame  Creates a new edge without any type information and connects it between this vertex and a newly created vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used to narrow the return type.  example:  @Adjacency(\"Foo\")\nBar addFoobar(ClassInitializer<? extends Bar> vertexInitializer)  @Adjacency(\"Foo\")\n<E extends Bar> E addFoobar(ClassInitializer<? extends E> vertexInitializer)  @Adjacency(\"Foo\")\n<E extends VertexFrame> E addFoobar(ClassInitializer<? extends E> vertexInitializer)",
            "title": "(ClassInitializer)"
        },
        {
            "location": "/core_annotations/#classinitializer-classinitializer",
            "text": "Valid return types:  Any Vertex Frame  Creates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge will hava type, and be initiated using, the second ClassInitializer argument. Java generics can, and should, be used to narrow the return type.  example:  @Adjacency(\"Foo\")\nBar addFoobar(ClassInitializer<? extends Bar> vertexInitializer,\n              ClassInitializer<?> edgeInitializer)  @Adjacency(\"Foo\")\n<E extends Bar> E addFoobar(ClassInitializer<? extends E> vertexInitializer,\n                            ClassInitializer<?> edgeInitializer)  @Adjacency(\"Foo\")\n<E extends VertexFrame> E addFoobar(ClassInitializer<? extends E> vertexInitializer,\n                                    ClassInitializer<?> edgeInitializer)",
            "title": "(ClassInitializer, ClassInitializer)"
        },
        {
            "location": "/core_annotations/#get-prefix_1",
            "text": "Valid method signatures:  () ,  (Class)  Get's one or more adjacent vertex from the graph.",
            "title": "get prefix"
        },
        {
            "location": "/core_annotations/#_5",
            "text": "Valid return types:  Any Vertex Frame  or  Object  or  VertexFrame  or  Iterator  Retrieves one or more of the adjacent vertex. If the return type is a specific Frame, an  Object , or a  VertexFrame  then only the first instance is returned. If the return type is an iterator then it will iterate over all matching vertex. When using an Iterator it is encouraged to use generics. The returned frames will always be instantiated as the type encoded in the graph if there is one.  Note:  If a type is specified that is more specific than the type of the returned element then an exception will be thrown. Therefore the return type specifed should always by the same type, or a super-type, of the expected return type. VertexFrame is always a safe return type for this method.  example:  @Adjacency(\"Foo\")\nBar getFoobar()  @Adjacency(\"Foo\")\n<E extends Bar> E getFoobar()  @Adjacency(\"Foo\")\n<E extends VertexFrame> E getFoobar()  @Adjacency(\"Foo\")\nIterator<Bar> getFoobar()  @Adjacency(\"Foo\")\n<E extends Bar> Iterator<E> getFoobar()  @Adjacency(\"Foo\")\n<E extends VertexFrame> Iterator<E> getFoobar()",
            "title": "()"
        },
        {
            "location": "/core_annotations/#class",
            "text": "Valid return types:  Any Vertex Frame  or  Object  or  VertexFrame  or  Iterator  Retrieves one or more of the adjacent vertex. If the return type is a specific Frame, an  Object , or a  VertexFrame  then only the first instance is returned. If the return type is an iterator then it will iterate over all matches vertex. When using an Iterator it is encouraged to use generics.  The Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype, to that of the argument will be returned.  example:  @Adjacency(\"Foo\")\nBar getFoobar(Class<? extends Bar> filter)  @Adjacency(\"Foo\")\n<E extends Bar> E getFoobar(Class<? extends E> filter)  @Adjacency(\"Foo\")\n<E extends VertexFrame> E getFoobar(Class<? extends E> filter)  @Adjacency(\"Foo\")\nIterator<Bar> getFoobar(Class<? extends Bar> filter)  @Adjacency(\"Foo\")\n<E extends Bar> Iterator<E> getFoobar(Class<? extends E> filter)  @Adjacency(\"Foo\")\n<E extends VertexFrame> Iterator<E> getFoobar(Class<? extends E> filter)",
            "title": "(Class)"
        },
        {
            "location": "/core_annotations/#remove-prefix_1",
            "text": "Valid method signatures:  (<Any Vertex Frame>)  Removes any edges which cause an adjacency.",
            "title": "remove prefix"
        },
        {
            "location": "/core_annotations/#any-vertex-frame_1",
            "text": "Valid return types:  void  Removes any edges which create an adjacency between the vurrent vertex and the vertex specified in the methods argument.  example:  @Adjacency(\"Foo\")\nvoid removeFoobar(Bar vertex)  @Adjacency(\"Foo\")\n<E extends Bar> void removeFoobar(E vertex)  @Adjacency(\"Foo\")\n<E extends VertexFrame> void removeFoobar(E vertex)",
            "title": "(&lt;Any Vertex Frame&gt;)"
        },
        {
            "location": "/core_annotations/#set-prefix_1",
            "text": "Valid method signatures:  (Iterator)  Creates new edges connected to several vertex.",
            "title": "set prefix"
        },
        {
            "location": "/core_annotations/#iterator",
            "text": "Valid return types:  void  The argument for this method must be an Iterator which iterates over any vertex Frames. It is suggested you specify a Generic Type for the Iterator for usability.  This method will iterate over all the vertex specified in the Iterator argument and create new edges to connect to it. The edges in the graph will not encode a type.  example:  @Adjacency(\"Foo\")\nvoid setFoobar(Iterator<Bar> vertex)  @Adjacency(\"Foo\")\n<E extends Bar> void setFoobar(Iterator<? extends E> vertex)  @Adjacency(\"Foo\")\n<E extends VertexFrame> void setFoobar(Iterator<? extends E> vertex)",
            "title": "(Iterator)"
        },
        {
            "location": "/getting_started/",
            "text": "Ferma provides three levels of type resolution: untyped, simple, and annotated. In untyped mode Ferma doesn't handle typing at all, instead the type must be explicitly indicated whenever querying. In simple mode Ferma provides type context encoded as graph element properties which ensures the same type comes out that goes in to a graph. In annotated mode all the features of simple mode are provided as well as enabling the use of annotations on abstract methods to instruct Ferma to dynamically construct byte code to implement the abstract methods at start up.\n\n\nDependency\n\u00b6\n\n\nTo include Ferma in your project of choice include the following Maven dependency into your build.\n\n\n<dependency>\n    <groupId>com.syncleus.ferma</groupId>\n    <artifactId>ferma</artifactId>\n    <version>3.0.0</version>\n</dependency>\n\n\n\n\nUntyped Mode Example\n\u00b6\n\n\nIn untyped mode there is no automatic typing. Whatever class is explicitly indicated is the type that will be instantiated when performing queries. Lets start with a simple example domain.\n\n\npublic class Person extends VertexFrame {\n  public String getName() {\n    return getProperty(\"name\");\n  }\n\n  public void setName(String name) {\n    setProperty(\"name\", name);\n  }\n\n  public List<? extends Knows> getKnowsList() {\n    return traverse((v) -> v.outE(\"knows\")).toList(Knows.class);\n  }\n\n  public Knows addKnows(Person friend) {\n    return addEdge(\"knows\", friend, Knows.class);\n  }\n}\n\npublic class Knows extends EdgeFrame {\n  public void setYears(int years) {\n    setProperty(\"years\", years);\n  }\n\n  public int getYears() {\n    return getProperty(\"years\");\n  }\n}\n\n\n\n\nAnd here is how you interact with the framed elements:\n\n\npublic void testUntyped() {\n  Graph g = new TinkerGraph();\n\n  // implies untyped mode\n  FramedGraph fg = new DelegatingFramedGraph(g);\n\n  Person p1 = fg.addFramedVertex(Person.class);\n  p1.setName(\"Jeff\");\n\n  Person p2 = fg.addFramedVertex(Person.class);\n  p2.setName(\"Julia\");\n  Knows knows = p1.addKnows(p2);\n  knows.setYears(15);\n\n  Person jeff = fg.traverse((g) -> g.v().has(\"name\", \"Jeff\")).next(Person.class);\n\n\n  Assert.assertEquals(\"Jeff\", jeff.getName());\n}\n\n\n\n\nSimple Mode Example\n\u00b6\n\n\nIn simple mode you must provide concrete classes, no abstract or interfaces allowed, and the class should always extend from a FramedVertex or FramedEdge. Simple mode doesn't provide any annotations either. The purpose of simple mode is to provide type resolution. Basically the type of object you use when adding to the graph is the same type you get out when reading from the graph.\n\n\nSay we extend the Person class with the Programmer class.\n\n\npublic class Programmer extends Person {\n}\n\n\n\n\nUsing simple mode will save the type of Java class the element was created with for use later:\n\n\npublic void testSimpleTyping() {\n  Graph g = new TinkerGraph();\n\n  // implies simple mode\n  FramedGraph fg = new DelegatingFramedGraph(g, true, false);\n\n  Person p1 = fg.addFramedVertex(Programmer.class);\n  p1.setName(\"Jeff\");\n\n  Person p2 = fg.addFramedVertex(Person.class);\n  p2.setName(\"Julia\");\n\n  Person jeff = fg.traverse((g) -> g.v().has(\"name\", \"Jeff\")).next(Person.class);\n  Person julia = fg.traverse((g) -> g.v().has(\"name\", \"Julia\")).next(Person.class);\n\n  Assert.assertEquals(Programmer.class, jeff.getClass());\n  Assert.assertEquals(Person.class, julia.getClass());\n}\n\n\n\n\nAnnotated Mode Example\n\u00b6\n\n\nIn annotated mode you can either provide concrete classes, abstract classes, or even interfaces. Abstract classes and concrete classes must extend from FramedVertex or FramedEdge, however, interfaces do not have this restriction. Annotated mode also provides a set of annotations which must be used to define any abstract methods that are to be implemented by the engine. Annotated mode provides the same type resolution as provided by simple mode with a bit more power to determine parent-child relationships at run time.\n\n\nThe same example as above done with annotations would look something like this.\n\n\npublic abstract class Person extends VertexFrame {\n  @Property(\"name\")\n  public abstract String getName();\n\n  @Property(\"name\")\n  public abstract void setName(String name);\n\n  @Adjacency(\"knows\")\n  public abstract Iterator<Person>; getKnowsPeople();\n\n  @Incidence(\"knows\")\n  public abstract Iterator<Knows> getKnows();\n\n  @Incidence(\"knows\")\n  public abstract Knows addKnows(Person friend);\n\n  public List<Person> getFriendsNamedBill() {\n    return traverse((v) -> v.out(\"knows\").has(\"name\", \"bill\").toList(Person.class);\n  }\n}\n\npublic abstract class Knows extends EdgeFrame {\n  @Property(\"years\")\n  public abstract void setYears(int years);\n\n  @Property(\"years\")\n  public abstract int getYears();\n\n  @InVertex\n  public abstract Person getIn();\n\n  @OutVertex\n  public abstract Person getIn();\n}\n\npublic abstract class Programmer extends Person {\n}\n\n\n\n\nIf we pass a collection of Class objects to the FramedGraph constructor then the annotated type resolver will be used. In this mode you want to tell the engine what classes you will be using so it can handle type resolution properly and construct the byte code for any abstract annotated methods.\n\n\npublic void testAnnotatedTyping() {\n  Set<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{\n                                                                    Person.class,\n                                                                    Programmer.class,\n                                                                    Knows.class}));\n  Graph g = new TinkerGraph();\n\n  //implies annotated mode\n  FramedGraph fg = new DelegatingFramedGraph(g, true, types);\n\n  Person p1 = fg.addFramedVertex(Programmer.class);\n  p1.setName(\"Jeff\");\n\n  Person p2 = fg.addFramedVertex(Person.class);\n  p2.setName(\"Julia\");\n\n  Person jeff = fg.traverse((g) -> g.v().has(\"name\", \"Jeff\")).next(Person.class);\n  Person julia = fg.traverse((g) -> g.v().has(\"name\", \"Julia\")).next(Person.class);\n\n  Assert.assertEquals(Programmer.class, jeff.getClass());\n  Assert.assertEquals(Person.class, julia.getClass());\n}",
            "title": "Getting Started"
        },
        {
            "location": "/getting_started/#dependency",
            "text": "To include Ferma in your project of choice include the following Maven dependency into your build.  <dependency>\n    <groupId>com.syncleus.ferma</groupId>\n    <artifactId>ferma</artifactId>\n    <version>3.0.0</version>\n</dependency>",
            "title": "Dependency"
        },
        {
            "location": "/getting_started/#untyped-mode-example",
            "text": "In untyped mode there is no automatic typing. Whatever class is explicitly indicated is the type that will be instantiated when performing queries. Lets start with a simple example domain.  public class Person extends VertexFrame {\n  public String getName() {\n    return getProperty(\"name\");\n  }\n\n  public void setName(String name) {\n    setProperty(\"name\", name);\n  }\n\n  public List<? extends Knows> getKnowsList() {\n    return traverse((v) -> v.outE(\"knows\")).toList(Knows.class);\n  }\n\n  public Knows addKnows(Person friend) {\n    return addEdge(\"knows\", friend, Knows.class);\n  }\n}\n\npublic class Knows extends EdgeFrame {\n  public void setYears(int years) {\n    setProperty(\"years\", years);\n  }\n\n  public int getYears() {\n    return getProperty(\"years\");\n  }\n}  And here is how you interact with the framed elements:  public void testUntyped() {\n  Graph g = new TinkerGraph();\n\n  // implies untyped mode\n  FramedGraph fg = new DelegatingFramedGraph(g);\n\n  Person p1 = fg.addFramedVertex(Person.class);\n  p1.setName(\"Jeff\");\n\n  Person p2 = fg.addFramedVertex(Person.class);\n  p2.setName(\"Julia\");\n  Knows knows = p1.addKnows(p2);\n  knows.setYears(15);\n\n  Person jeff = fg.traverse((g) -> g.v().has(\"name\", \"Jeff\")).next(Person.class);\n\n\n  Assert.assertEquals(\"Jeff\", jeff.getName());\n}",
            "title": "Untyped Mode Example"
        },
        {
            "location": "/getting_started/#simple-mode-example",
            "text": "In simple mode you must provide concrete classes, no abstract or interfaces allowed, and the class should always extend from a FramedVertex or FramedEdge. Simple mode doesn't provide any annotations either. The purpose of simple mode is to provide type resolution. Basically the type of object you use when adding to the graph is the same type you get out when reading from the graph.  Say we extend the Person class with the Programmer class.  public class Programmer extends Person {\n}  Using simple mode will save the type of Java class the element was created with for use later:  public void testSimpleTyping() {\n  Graph g = new TinkerGraph();\n\n  // implies simple mode\n  FramedGraph fg = new DelegatingFramedGraph(g, true, false);\n\n  Person p1 = fg.addFramedVertex(Programmer.class);\n  p1.setName(\"Jeff\");\n\n  Person p2 = fg.addFramedVertex(Person.class);\n  p2.setName(\"Julia\");\n\n  Person jeff = fg.traverse((g) -> g.v().has(\"name\", \"Jeff\")).next(Person.class);\n  Person julia = fg.traverse((g) -> g.v().has(\"name\", \"Julia\")).next(Person.class);\n\n  Assert.assertEquals(Programmer.class, jeff.getClass());\n  Assert.assertEquals(Person.class, julia.getClass());\n}",
            "title": "Simple Mode Example"
        },
        {
            "location": "/getting_started/#annotated-mode-example",
            "text": "In annotated mode you can either provide concrete classes, abstract classes, or even interfaces. Abstract classes and concrete classes must extend from FramedVertex or FramedEdge, however, interfaces do not have this restriction. Annotated mode also provides a set of annotations which must be used to define any abstract methods that are to be implemented by the engine. Annotated mode provides the same type resolution as provided by simple mode with a bit more power to determine parent-child relationships at run time.  The same example as above done with annotations would look something like this.  public abstract class Person extends VertexFrame {\n  @Property(\"name\")\n  public abstract String getName();\n\n  @Property(\"name\")\n  public abstract void setName(String name);\n\n  @Adjacency(\"knows\")\n  public abstract Iterator<Person>; getKnowsPeople();\n\n  @Incidence(\"knows\")\n  public abstract Iterator<Knows> getKnows();\n\n  @Incidence(\"knows\")\n  public abstract Knows addKnows(Person friend);\n\n  public List<Person> getFriendsNamedBill() {\n    return traverse((v) -> v.out(\"knows\").has(\"name\", \"bill\").toList(Person.class);\n  }\n}\n\npublic abstract class Knows extends EdgeFrame {\n  @Property(\"years\")\n  public abstract void setYears(int years);\n\n  @Property(\"years\")\n  public abstract int getYears();\n\n  @InVertex\n  public abstract Person getIn();\n\n  @OutVertex\n  public abstract Person getIn();\n}\n\npublic abstract class Programmer extends Person {\n}  If we pass a collection of Class objects to the FramedGraph constructor then the annotated type resolver will be used. In this mode you want to tell the engine what classes you will be using so it can handle type resolution properly and construct the byte code for any abstract annotated methods.  public void testAnnotatedTyping() {\n  Set<Class<?>> types = new HashSet<Class<?>>(Arrays.asList(new Class<?>[]{\n                                                                    Person.class,\n                                                                    Programmer.class,\n                                                                    Knows.class}));\n  Graph g = new TinkerGraph();\n\n  //implies annotated mode\n  FramedGraph fg = new DelegatingFramedGraph(g, true, types);\n\n  Person p1 = fg.addFramedVertex(Programmer.class);\n  p1.setName(\"Jeff\");\n\n  Person p2 = fg.addFramedVertex(Person.class);\n  p2.setName(\"Julia\");\n\n  Person jeff = fg.traverse((g) -> g.v().has(\"name\", \"Jeff\")).next(Person.class);\n  Person julia = fg.traverse((g) -> g.v().has(\"name\", \"Julia\")).next(Person.class);\n\n  Assert.assertEquals(Programmer.class, jeff.getClass());\n  Assert.assertEquals(Person.class, julia.getClass());\n}",
            "title": "Annotated Mode Example"
        },
        {
            "location": "/glossary/",
            "text": "Frame\n - A class from the schema that represents an element from the graph. A frame usually extends either a VertexFrame or an EdgeFrame, though they are not required to do so.\n\n\nElement\n - Either a vertex or an edge in a graph.",
            "title": "Glossary"
        }
    ]
}