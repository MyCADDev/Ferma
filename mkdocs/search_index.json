{
    "docs": [
        {
            "location": "/", 
            "text": "An ORM / OGM for the Apache TinkerPop\u2122 graph stack.\n\n\nLicensed under the Apache Software License v2\n\n\nThe Ferma project was originally created as an alternative to the\nTinkerPop2 Frames project. Which at the time lacked features needed by\nthe community, and its performance was cripplingly slow. Today Ferma is\na robust framework that takes on a role similar to an Object-relational\nModel (ORM) library for traditional databases. Ferma is often referred\nto as a Object-graph Model (OGM) library, and maps Java objects to\nelements in a graph such as a Vertex or an Edges. In short it allows a\nschema to be defined using java interfaces and classes which provides a\nlevel of abstraction for interacting with the underlying graph.\n\n\nFerma 3.x \nSupports TinkerPop3\n. For tinkerPop2 support use Ferma\nversion 2.x.\n\n\nAnnotated classes in Ferma have their abstract methods implemented using\ncode generation during start-up with Byte Buddy, avoiding the need for\nproxy classes. This in turn significantly improves performance when\ncompared with TinkerPop Frames and other frameworks. Ferma offers many\nfeatures including several annotation types to reduce the need for\nboilerplate code as well as handling Java typing transparently. This\nensures whatever the type of the object is when you persist it to the\ngraph the same Java type will be used when instantiating a class off of\nthe graph.\n\n\nFerma is designed to easily replace TinkerPop Frames in existing code,\nas such, the annotations provided by Ferma are a super-set of those\nprovided by TinkerPop Frames.\n\n\nFerma is built directly on top of TinkerPop and allows access to all of\nthe internals. This ensures all the TinkerPop features are available to\nthe end-user. The TinkerPop stack provides several tools which can be\nused to work with the Ferma engine.\n\n\n\n\nGremlin\n, a database agnostic query language for Graph Databases.\n\n\nGremlin Server\n, a server that provides an interface for\n    executing Gremlin on remote machines.\n\n\na data-flow framework for splitting, merging, filtering, and\n    transforming of data\n\n\nGraph Computer\n, a framework for running algorithms against a\n    Graph Database.\n\n\nSupport for both \nOLTP\n and \nOLAP\n engines.\n\n\nTinkerGraph\n a Graph Database and the reference implementation\n    for TinkerPop.\n\n\nNative \nGephi\n integration for visualizing graphs.\n\n\nInterfaces for most major Graph Compute Engines including \nHadoop\n    M/R\n. \nSpark\n, and \nGiraph\n.\n\n\n\n\nFerma also supports any of the many databases compatible with TinkerPop\nincluding the following.\n\n\n\n\nTitan\n\n\nNeo4j\n\n\nOrientDB\n\n\nMongoDB\n\n\nOracle NoSQL\n\n\nTinkerGraph\n\n\n\n\nFerma Javadocs:\n\nlatest\n -\n\n3.2.1\n -\n\n3.2.0\n -\n\n3.1.0\n -\n\n3.0.3\n -\n\n3.0.2\n -\n\n3.0.1\n -\n\n3.0.0\n -\n\n2.4.0\n -\n\n2.3.0\n -\n\n2.2.2\n -\n\n2.2.1\n -\n\n2.2.0\n -\n\n2.1.0\n -\n\n2.0.6\n -\n\n2.0.5\n -\n\n2.0.4\n -\n\n2.0.3\n -\n\n2.0.2\n -\n\n2.0.1\n -\n\n2.0.0\n\n\nFor support please use\n\nGitter\n\nor the \nofficial Ferma mailing list\n.\n\n\nPlease file bugs and feature requests on\n\nGithub\n.\n\n\nObtaining the Source\n\n\nThe official source repository for Ferma is located in the Syncleus\nGithub repository and can be cloned using the following command.\n\n\ngit clone https://github.com/Syncleus/Ferma.git", 
            "title": "Home"
        }, 
        {
            "location": "/#obtaining-the-source", 
            "text": "The official source repository for Ferma is located in the Syncleus\nGithub repository and can be cloned using the following command.  git clone https://github.com/Syncleus/Ferma.git", 
            "title": "Obtaining the Source"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Ferma provides three levels of type resolution: untyped, simple, and annotated. In untyped mode Ferma doesn't handle\ntyping at all, instead the type must be explicitly indicated whenever querying. In simple mode Ferma provides type\ncontext encoded as graph element properties which ensures the same type comes out that goes in to a graph. In annotated\nmode all the features of simple mode are provided as well as enabling the use of annotations on abstract methods to\ninstruct Ferma to dynamically construct byte code to implement the abstract methods at start up.\n\n\nDependency\n\n\nTo include Ferma in your project of choice include the following Maven dependency into your build.\n\n\ndependency\n\n    \ngroupId\ncom.syncleus.ferma\n/groupId\n\n    \nartifactId\nferma\n/artifactId\n\n    \nversion\n3.2.1\n/version\n\n\n/dependency\n\n\n\n\n\nUntyped Mode Example\n\n\nIn untyped mode there is no automatic typing. Whatever class is explicitly indicated is the type that will be\ninstantiated when performing queries. Lets start with a simple example domain.\n\n\npublic\n \nclass\n \nPerson\n \nextends\n \nAbstractVertexFrame\n \n{\n\n  \npublic\n \nString\n \ngetName\n()\n \n{\n\n    \nreturn\n \ngetProperty\n(\nname\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetName\n(\nString\n \nname\n)\n \n{\n\n    \nsetProperty\n(\nname\n,\n \nname\n);\n\n  \n}\n\n\n  \npublic\n \nList\n?\n \nextends\n \nKnows\n \ngetKnowsList\n()\n \n{\n\n    \nreturn\n \ntraverse\n((\nv\n)\n \n-\n \nv\n.\noutE\n(\nknows\n)).\ntoList\n(\nKnows\n.\nclass\n);\n\n  \n}\n\n\n  \npublic\n \nKnows\n \naddKnows\n(\nPerson\n \nfriend\n)\n \n{\n\n    \nreturn\n \naddFramedEdge\n(\nknows\n,\n \nfriend\n,\n \nKnows\n.\nclass\n);\n\n  \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nKnows\n \nextends\n \nAbstractEdgeFrame\n \n{\n\n  \npublic\n \nvoid\n \nsetYears\n(\nint\n \nyears\n)\n \n{\n\n    \nsetProperty\n(\nyears\n,\n \nyears\n);\n\n  \n}\n\n\n  \npublic\n \nint\n \ngetYears\n()\n \n{\n\n    \nreturn\n \ngetProperty\n(\nyears\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nAnd here is how you interact with the framed elements:\n\n\npublic\n \nvoid\n \ntestUntyped\n()\n \n{\n\n  \nGraph\n \ngraph\n \n=\n \nTinkerGraph\n.\nopen\n();\n\n\n  \n// implies untyped mode\n\n  \nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ngraph\n);\n\n\n  \nPerson\n \np1\n \n=\n \nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n  \np1\n.\nsetName\n(\nJeff\n);\n\n\n  \nPerson\n \np2\n \n=\n \nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n  \np2\n.\nsetName\n(\nJulia\n);\n\n  \nKnows\n \nknows\n \n=\n \np1\n.\naddKnows\n(\np2\n);\n\n  \nknows\n.\nsetYears\n(\n15\n);\n\n\n  \nPerson\n \njeff\n \n=\n \nfg\n.\ntraverse\n((\ng\n)\n \n-\n \ng\n.\nV\n().\nhas\n(\nname\n,\n \nJeff\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n\n\n  \nAssert\n.\nassertEquals\n(\nJeff\n,\n \njeff\n.\ngetName\n());\n\n\n}\n\n\n\n\n\nSimple Mode Example\n\n\nIn simple mode you must provide concrete classes, no abstract or interfaces allowed, and the class should always extend\nfrom a FramedVertex or FramedEdge. Simple mode doesn't provide any annotations either. The purpose of simple mode is to\nprovide type resolution. Basically the type of object you use when adding to the graph is the same type you get out when\nreading from the graph.\n\n\nSay we extend the Person class with the Programmer class.\n\n\npublic\n \nclass\n \nProgrammer\n \nextends\n \nPerson\n \n{\n\n\n}\n\n\n\n\n\nUsing simple mode will save the type of Java class the element was created with for use later:\n\n\npublic\n \nvoid\n \ntestSimpleTyping\n()\n \n{\n\n  \nGraph\n \ngraph\n \n=\n \nTinkerGraph\n.\nopen\n();\n\n\n  \n// implies simple mode\n\n  \nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ngraph\n,\n \ntrue\n,\n \nfalse\n);\n\n\n  \nPerson\n \np1\n \n=\n \nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n  \np1\n.\nsetName\n(\nJeff\n);\n\n\n  \nPerson\n \np2\n \n=\n \nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n  \np2\n.\nsetName\n(\nJulia\n);\n\n\n  \nPerson\n \njeff\n \n=\n \nfg\n.\ntraverse\n((\ng\n)\n \n-\n \ng\n.\nV\n().\nhas\n(\nname\n,\n \nJeff\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n  \nPerson\n \njulia\n \n=\n \nfg\n.\ntraverse\n((\ng\n)\n \n-\n \ng\n.\nV\n().\nhas\n(\nname\n,\n \nJulia\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n\n  \nAssert\n.\nassertEquals\n(\nProgrammer\n.\nclass\n,\n \njeff\n.\ngetClass\n());\n\n  \nAssert\n.\nassertEquals\n(\nPerson\n.\nclass\n,\n \njulia\n.\ngetClass\n());\n\n\n}\n\n\n\n\n\nAnnotated Mode Example\n\n\nIn annotated mode you can either provide concrete classes, abstract classes, or even interfaces. Abstract classes and\nconcrete classes must extend from FramedVertex or FramedEdge, however, interfaces do not have this restriction.\nAnnotated mode also provides a set of annotations which must be used to define any abstract methods that are to be\nimplemented by the engine. Annotated mode provides the same type resolution as provided by simple mode with a bit more\npower to determine parent-child relationships at run time.\n\n\nThe same example as above done with annotations would look something like this.\n\n\npublic\n \nabstract\n \nclass\n \nPerson\n \nextends\n \nAbstractVertexFrame\n \n{\n\n  \n@Property\n(\nname\n)\n\n  \npublic\n \nabstract\n \nString\n \ngetName\n();\n\n\n  \n@Property\n(\nname\n)\n\n  \npublic\n \nabstract\n \nvoid\n \nsetName\n(\nString\n \nname\n);\n\n\n  \n@Adjacency\n(\nlabel\n \n=\n \nknows\n)\n\n  \npublic\n \nabstract\n \nList\nPerson\n \ngetKnowsPeople\n();\n\n\n  \n@Incidence\n(\nlabel\n \n=\n \nknows\n)\n\n  \npublic\n \nabstract\n \nList\nKnows\n \ngetKnows\n();\n\n\n  \n@Incidence\n(\nlabel\n \n=\n \nknows\n)\n\n  \npublic\n \nabstract\n \nKnows\n \naddKnows\n(\nPerson\n \nfriend\n);\n\n\n  \npublic\n \nList\n?\n \nextends\n \nPerson\n \ngetFriendsNamedBill\n()\n \n{\n\n      \nreturn\n \nthis\n.\ntraverse\n(\ninput\n \n-\n \ninput\n.\nout\n(\nknows\n).\nhas\n(\nname\n,\n \nbill\n)).\ntoList\n(\nPerson\n.\nclass\n);\n\n  \n}\n\n\n}\n\n\n\npublic\n \nabstract\n \nclass\n \nKnows\n \nextends\n \nAbstractEdgeFrame\n \n{\n\n  \n@Property\n(\nyears\n)\n\n  \npublic\n \nabstract\n \nvoid\n \nsetYears\n(\nint\n \nyears\n);\n\n\n  \n@Property\n(\nyears\n)\n\n  \npublic\n \nabstract\n \nint\n \ngetYears\n();\n\n\n  \n@InVertex\n\n  \npublic\n \nabstract\n \nPerson\n \ngetIn\n();\n\n\n  \n@OutVertex\n\n  \npublic\n \nabstract\n \nPerson\n \ngetOut\n();\n\n\n}\n\n\n\npublic\n \nabstract\n \nclass\n \nProgrammer\n \nextends\n \nPerson\n \n{\n\n\n}\n\n\n\n\n\nIf we pass a collection of Class objects to the FramedGraph constructor then the annotated type resolver will be used.\nIn this mode you want to tell the engine what classes you will be using so it can handle type resolution properly and\nconstruct the byte code for any abstract annotated methods.\n\n\npublic\n \nvoid\n \ntestAnnotatedTyping\n()\n \n{\n\n  \nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\n\n                \nPerson\n.\nclass\n,\n\n                \nProgrammer\n.\nclass\n,\n\n                \nKnows\n.\nclass\n}));\n\n  \nGraph\n \ngraph\n \n=\n \nTinkerGraph\n.\nopen\n();\n\n\n  \n//implies annotated mode\n\n  \nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ngraph\n,\n \ntrue\n,\n \ntypes\n);\n\n\n  \nPerson\n \njeff\n \n=\n \nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n  \njeff\n.\nsetName\n(\nJeff\n);\n\n\n  \nPerson\n \njulia\n \n=\n \nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n  \njulia\n.\nsetName\n(\nJulia\n);\n\n  \njulia\n.\naddKnows\n(\njeff\n);\n\n\n  \nPerson\n \njuliaAgain\n \n=\n \nfg\n.\ntraverse\n((\ng\n)\n \n-\n \ng\n.\nV\n().\nhas\n(\nname\n,\n \nJulia\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n  \nPerson\n \njeffAgain\n \n=\n \njuliaAgain\n.\ngetKnowsPeople\n().\nget\n(\n0\n);\n\n\n  \nAssert\n.\nassertTrue\n(\nProgrammer\n.\nclass\n.\nisAssignableFrom\n(\njeffAgain\n.\ngetClass\n()));\n\n  \nAssert\n.\nassertTrue\n(\nPerson\n.\nclass\n.\nisAssignableFrom\n(\njuliaAgain\n.\ngetClass\n()));\n\n\n}", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#dependency", 
            "text": "To include Ferma in your project of choice include the following Maven dependency into your build.  dependency \n     groupId com.syncleus.ferma /groupId \n     artifactId ferma /artifactId \n     version 3.2.1 /version  /dependency", 
            "title": "Dependency"
        }, 
        {
            "location": "/getting_started/#untyped-mode-example", 
            "text": "In untyped mode there is no automatic typing. Whatever class is explicitly indicated is the type that will be\ninstantiated when performing queries. Lets start with a simple example domain.  public   class   Person   extends   AbstractVertexFrame   { \n   public   String   getName ()   { \n     return   getProperty ( name ); \n   } \n\n   public   void   setName ( String   name )   { \n     setProperty ( name ,   name ); \n   } \n\n   public   List ?   extends   Knows   getKnowsList ()   { \n     return   traverse (( v )   -   v . outE ( knows )). toList ( Knows . class ); \n   } \n\n   public   Knows   addKnows ( Person   friend )   { \n     return   addFramedEdge ( knows ,   friend ,   Knows . class ); \n   }  }  public   class   Knows   extends   AbstractEdgeFrame   { \n   public   void   setYears ( int   years )   { \n     setProperty ( years ,   years ); \n   } \n\n   public   int   getYears ()   { \n     return   getProperty ( years ); \n   }  }   And here is how you interact with the framed elements:  public   void   testUntyped ()   { \n   Graph   graph   =   TinkerGraph . open (); \n\n   // implies untyped mode \n   FramedGraph   fg   =   new   DelegatingFramedGraph ( graph ); \n\n   Person   p1   =   fg . addFramedVertex ( Person . class ); \n   p1 . setName ( Jeff ); \n\n   Person   p2   =   fg . addFramedVertex ( Person . class ); \n   p2 . setName ( Julia ); \n   Knows   knows   =   p1 . addKnows ( p2 ); \n   knows . setYears ( 15 ); \n\n   Person   jeff   =   fg . traverse (( g )   -   g . V (). has ( name ,   Jeff )). next ( Person . class ); \n\n\n   Assert . assertEquals ( Jeff ,   jeff . getName ());  }", 
            "title": "Untyped Mode Example"
        }, 
        {
            "location": "/getting_started/#simple-mode-example", 
            "text": "In simple mode you must provide concrete classes, no abstract or interfaces allowed, and the class should always extend\nfrom a FramedVertex or FramedEdge. Simple mode doesn't provide any annotations either. The purpose of simple mode is to\nprovide type resolution. Basically the type of object you use when adding to the graph is the same type you get out when\nreading from the graph.  Say we extend the Person class with the Programmer class.  public   class   Programmer   extends   Person   {  }   Using simple mode will save the type of Java class the element was created with for use later:  public   void   testSimpleTyping ()   { \n   Graph   graph   =   TinkerGraph . open (); \n\n   // implies simple mode \n   FramedGraph   fg   =   new   DelegatingFramedGraph ( graph ,   true ,   false ); \n\n   Person   p1   =   fg . addFramedVertex ( Programmer . class ); \n   p1 . setName ( Jeff ); \n\n   Person   p2   =   fg . addFramedVertex ( Person . class ); \n   p2 . setName ( Julia ); \n\n   Person   jeff   =   fg . traverse (( g )   -   g . V (). has ( name ,   Jeff )). next ( Person . class ); \n   Person   julia   =   fg . traverse (( g )   -   g . V (). has ( name ,   Julia )). next ( Person . class ); \n\n   Assert . assertEquals ( Programmer . class ,   jeff . getClass ()); \n   Assert . assertEquals ( Person . class ,   julia . getClass ());  }", 
            "title": "Simple Mode Example"
        }, 
        {
            "location": "/getting_started/#annotated-mode-example", 
            "text": "In annotated mode you can either provide concrete classes, abstract classes, or even interfaces. Abstract classes and\nconcrete classes must extend from FramedVertex or FramedEdge, however, interfaces do not have this restriction.\nAnnotated mode also provides a set of annotations which must be used to define any abstract methods that are to be\nimplemented by the engine. Annotated mode provides the same type resolution as provided by simple mode with a bit more\npower to determine parent-child relationships at run time.  The same example as above done with annotations would look something like this.  public   abstract   class   Person   extends   AbstractVertexFrame   { \n   @Property ( name ) \n   public   abstract   String   getName (); \n\n   @Property ( name ) \n   public   abstract   void   setName ( String   name ); \n\n   @Adjacency ( label   =   knows ) \n   public   abstract   List Person   getKnowsPeople (); \n\n   @Incidence ( label   =   knows ) \n   public   abstract   List Knows   getKnows (); \n\n   @Incidence ( label   =   knows ) \n   public   abstract   Knows   addKnows ( Person   friend ); \n\n   public   List ?   extends   Person   getFriendsNamedBill ()   { \n       return   this . traverse ( input   -   input . out ( knows ). has ( name ,   bill )). toList ( Person . class ); \n   }  }  public   abstract   class   Knows   extends   AbstractEdgeFrame   { \n   @Property ( years ) \n   public   abstract   void   setYears ( int   years ); \n\n   @Property ( years ) \n   public   abstract   int   getYears (); \n\n   @InVertex \n   public   abstract   Person   getIn (); \n\n   @OutVertex \n   public   abstract   Person   getOut ();  }  public   abstract   class   Programmer   extends   Person   {  }   If we pass a collection of Class objects to the FramedGraph constructor then the annotated type resolver will be used.\nIn this mode you want to tell the engine what classes you will be using so it can handle type resolution properly and\nconstruct the byte code for any abstract annotated methods.  public   void   testAnnotatedTyping ()   { \n   Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ \n                 Person . class , \n                 Programmer . class , \n                 Knows . class })); \n   Graph   graph   =   TinkerGraph . open (); \n\n   //implies annotated mode \n   FramedGraph   fg   =   new   DelegatingFramedGraph ( graph ,   true ,   types ); \n\n   Person   jeff   =   fg . addFramedVertex ( Programmer . class ); \n   jeff . setName ( Jeff ); \n\n   Person   julia   =   fg . addFramedVertex ( Person . class ); \n   julia . setName ( Julia ); \n   julia . addKnows ( jeff ); \n\n   Person   juliaAgain   =   fg . traverse (( g )   -   g . V (). has ( name ,   Julia )). next ( Person . class ); \n   Person   jeffAgain   =   juliaAgain . getKnowsPeople (). get ( 0 ); \n\n   Assert . assertTrue ( Programmer . class . isAssignableFrom ( jeffAgain . getClass ())); \n   Assert . assertTrue ( Person . class . isAssignableFrom ( juliaAgain . getClass ()));  }", 
            "title": "Annotated Mode Example"
        }, 
        {
            "location": "/features/", 
            "text": "The following gives a quick breakdown of some of the features of the Ferma framework along with examples.\n\n\n\n\nJPA-like Annotations\n\n\nType information encoded into graph\n\n\nFraming of elements instantiated according to type hierarchy\n\n\nElement queried by type hierarchy\n\n\nTurning off type resolution on a per call basis\n\n\nChanging the encoded graph type already stored in the database\n\n\nCustomizing the way type information is stored in the graph\n\n\nTinkerpop 2 support\n\n\nTinkerpop 3 support\n\n\n\n\nJPA-like Annotations\n\n\npublic\n \nabstract\n \nclass\n \nPerson\n \nextends\n \nAbstractVertexFrame\n \n{\n\n  \n@Property\n(\nname\n)\n\n  \npublic\n \nabstract\n \nString\n \ngetName\n();\n\n\n  \n@Property\n(\nname\n)\n\n  \npublic\n \nabstract\n \nvoid\n \nsetName\n(\nString\n \nname\n);\n\n\n  \n@Adjacency\n(\nlabel\n \n=\n \nknows\n)\n\n  \npublic\n \nabstract\n \nList\nPerson\n \ngetKnowsPeople\n();\n\n\n}\n\n\n\npublic\n \nabstract\n \nclass\n \nProgrammer\n \nextends\n \nPerson\n \n{\n\n\n}\n\n\n\npublic\n \nvoid\n \ntestAnnotatedTyping\n()\n \n{\n\n  \nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\n\n                \nPerson\n.\nclass\n,\n\n                \nProgrammer\n.\nclass\n,\n\n                \nKnows\n.\nclass\n}));\n\n  \nGraph\n \ngraph\n \n=\n \nTinkerGraph\n.\nopen\n();\n\n\n  \n//implies annotated mode\n\n  \nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ngraph\n,\n \ntrue\n,\n \ntypes\n);\n\n\n  \nPerson\n \njeff\n \n=\n \nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n  \njeff\n.\nsetName\n(\nJeff\n);\n\n\n  \nPerson\n \njulia\n \n=\n \nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n  \njulia\n.\nsetName\n(\nJulia\n);\n\n  \njulia\n.\naddKnows\n(\njeff\n);\n\n\n  \nPerson\n \njuliaAgain\n \n=\n \nfg\n.\ntraverse\n((\ng\n)\n \n-\n \ng\n.\nV\n().\nhas\n(\nname\n,\n \nJulia\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n  \nPerson\n \njeffAgain\n \n=\n \njuliaAgain\n.\ngetKnowsPeople\n().\nget\n(\n0\n);\n\n\n  \nassert\n \njeffAgain\n \ninstanceof\n \nProgrammer\n;\n\n  \nassert\n \njeffAgain\n.\ngetName\n().\nequals\n(\nJeff\n);\n\n\n}\n\n\n\n\n\nType information encoded into graph\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n}));\n\n\nGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntypes\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n\nPerson\n \nperson\n \n=\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n()).\nnext\n(\nProgram\n.\nclass\n);\n\n\n\nString\n \npersonClassName\n \n=\n \nPerson\n.\nclass\n.\ngetName\n();\n\n\nString\n \nencodedClassName\n \n=\n \nperson\n.\ngetProperty\n(\nPolymorphicTypeResolver\n.\nTYPE_RESOLUTION_KEY\n)\n\n\nassert\n \npersonClassName\n.\nequals\n(\nencodedClassName\n);\n\n\n\n\n\nFraming instantiated by type hierarchy\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n,\n\n                                                                         \nProgrammer\n.\nclass\n}));\n\n\nTinkerGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntypes\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n\n\n//make sure the newly added node is actually a programmer\n\n\nPerson\n \nprogrammer\n \n=\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n()).\nnext\n(\nPerson\n.\nclass\n);\n\n\nassert\n \nprogrammer\n \ninstanceof\n \nProgrammer\n;\n\n\n\n\n\nElement queried by type hierarchy\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n,\n\n                                                                         \nProgrammer\n.\nclass\n}));\n\n\nTinkerGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntypes\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n\nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n\n\n//counts how many people (or subclasses thereof) in the graph.\n\n\nassert\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\ngetTypeResolver\n().\nhasType\n(\ng\n.\nV\n(),\n \nPerson\n.\nclass\n)).\ntoList\n(\nPerson\n.\nclass\n).\nsize\n()\n \n==\n \n2\n;\n\n\n//counts how many programmers are in the graph\n\n\nassert\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\ngetTypeResolver\n().\nhasType\n(\ng\n.\nV\n(),\n \nProgrammer\n.\nclass\n)).\ntoList\n(\nPerson\n.\nclass\n).\nsize\n()\n \n==\n \n1\n;\n\n\n\n\n\nTurning off type resolution per call\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n,\n\n                                                                         \nProgrammer\n.\nclass\n}));\n\n\nTinkerGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntypes\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n\n\n//With type resolution is active it should be a programmer\n\n\nassert\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n()).\nnext\n(\nPerson\n.\nclass\n)\n \ninstanceof\n \nProgrammer\n;\n\n\n//With type resolution bypassed it is no longer a programmer\n\n\nassert\n \n!(\nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n()).\nnextExplicit\n(\nPerson\n.\nclass\n)\n \ninstanceof\n \nProgrammer\n);\n\n\n\n\n\nChanging type encoded in the graph\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n,\n\n                                                                         \nProgrammer\n.\nclass\n}));\n\n\nTinkerGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \ntypes\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n\n\n//make sure the newly added node is actually a programmer\n\n\nPerson\n \nprogrammer\n \n=\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n()).\nnext\n(\nPerson\n.\nclass\n);\n\n\nassert\n \nprogrammer\n \ninstanceof\n \nProgrammer\n;\n\n\n\n//change the type resolution to person\n\n\nprogrammer\n.\nsetTypeResolution\n(\nPerson\n.\nclass\n);\n\n\n\n//make sure the newly added node is actually a programmer\n\n\nPerson\n \nperson\n \n=\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n()).\nnext\n(\nPerson\n.\nclass\n);\n\n\nassert\n \n!(\nperson\n \ninstanceof\n \nProgrammer\n);\n\n\n\n\n\nCustomizing how types are encoded\n\n\nSet\nClass\n?\n \ntypes\n \n=\n \nnew\n \nHashSet\nClass\n?\n(\nArrays\n.\nasList\n(\nnew\n \nClass\n?\n[]{\nPerson\n.\nclass\n}));\n\n\nfinal\n \nReflectionCache\n \ncache\n \n=\n \nnew\n \nReflectionCache\n(\ntypes\n);\n\n\nFrameFactory\n \nfactory\n \n=\n \nnew\n \nAnnotationFrameFactory\n(\ncache\n);\n\n\nTypeResolver\n \nresolver\n \n=\n \nnew\n \nPolymorphicTypeResolver\n(\ncache\n,\n \ncustomTypeKey\n);\n\n\nGraph\n \ng\n \n=\n \nnew\n \nTinkerGraph\n();\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\ng\n,\n \nfactory\n,\n \nresolver\n);\n\n\n\nfg\n.\naddFramedVertex\n(\nPerson\n.\nclass\n);\n\n\nPerson\n \nperson\n \n=\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n()).\nnext\n(\nProgrammer\n.\nclass\n);\n\n\n\nString\n \npersonClassName\n \n=\n \nPerson\n.\nclass\n.\ngetName\n();\n\n\nString\n \nencodedClassName\n \n=\n \nperson\n.\ngetProperty\n(\ncustomTypeKey\n)\n\n\nassert\n \npersonClassName\n.\nequals\n(\nencodedClassName\n);", 
            "title": "Features"
        }, 
        {
            "location": "/features/#jpa-like-annotations", 
            "text": "public   abstract   class   Person   extends   AbstractVertexFrame   { \n   @Property ( name ) \n   public   abstract   String   getName (); \n\n   @Property ( name ) \n   public   abstract   void   setName ( String   name ); \n\n   @Adjacency ( label   =   knows ) \n   public   abstract   List Person   getKnowsPeople ();  }  public   abstract   class   Programmer   extends   Person   {  }  public   void   testAnnotatedTyping ()   { \n   Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ \n                 Person . class , \n                 Programmer . class , \n                 Knows . class })); \n   Graph   graph   =   TinkerGraph . open (); \n\n   //implies annotated mode \n   FramedGraph   fg   =   new   DelegatingFramedGraph ( graph ,   true ,   types ); \n\n   Person   jeff   =   fg . addFramedVertex ( Programmer . class ); \n   jeff . setName ( Jeff ); \n\n   Person   julia   =   fg . addFramedVertex ( Person . class ); \n   julia . setName ( Julia ); \n   julia . addKnows ( jeff ); \n\n   Person   juliaAgain   =   fg . traverse (( g )   -   g . V (). has ( name ,   Julia )). next ( Person . class ); \n   Person   jeffAgain   =   juliaAgain . getKnowsPeople (). get ( 0 ); \n\n   assert   jeffAgain   instanceof   Programmer ; \n   assert   jeffAgain . getName (). equals ( Jeff );  }", 
            "title": "JPA-like Annotations"
        }, 
        {
            "location": "/features/#type-information-encoded-into-graph", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class }));  Graph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   types );  fg . addFramedVertex ( Person . class );  Person   person   =   fg . traverse ( g   -   g . V ()). next ( Program . class );  String   personClassName   =   Person . class . getName ();  String   encodedClassName   =   person . getProperty ( PolymorphicTypeResolver . TYPE_RESOLUTION_KEY )  assert   personClassName . equals ( encodedClassName );", 
            "title": "Type information encoded into graph"
        }, 
        {
            "location": "/features/#framing-instantiated-by-type-hierarchy", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class , \n                                                                          Programmer . class }));  TinkerGraph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   types );  fg . addFramedVertex ( Programmer . class );  //make sure the newly added node is actually a programmer  Person   programmer   =   fg . traverse ( g   -   g . V ()). next ( Person . class );  assert   programmer   instanceof   Programmer ;", 
            "title": "Framing instantiated by type hierarchy"
        }, 
        {
            "location": "/features/#element-queried-by-type-hierarchy", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class , \n                                                                          Programmer . class }));  TinkerGraph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   types );  fg . addFramedVertex ( Programmer . class );  fg . addFramedVertex ( Person . class );  //counts how many people (or subclasses thereof) in the graph.  assert   fg . traverse ( g   -   g . getTypeResolver (). hasType ( g . V (),   Person . class )). toList ( Person . class ). size ()   ==   2 ;  //counts how many programmers are in the graph  assert   fg . traverse ( g   -   g . getTypeResolver (). hasType ( g . V (),   Programmer . class )). toList ( Person . class ). size ()   ==   1 ;", 
            "title": "Element queried by type hierarchy"
        }, 
        {
            "location": "/features/#turning-off-type-resolution-per-call", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class , \n                                                                          Programmer . class }));  TinkerGraph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   types );  fg . addFramedVertex ( Programmer . class );  //With type resolution is active it should be a programmer  assert   fg . traverse ( g   -   g . V ()). next ( Person . class )   instanceof   Programmer ;  //With type resolution bypassed it is no longer a programmer  assert   !( fg . traverse ( g   -   g . V ()). nextExplicit ( Person . class )   instanceof   Programmer );", 
            "title": "Turning off type resolution per call"
        }, 
        {
            "location": "/features/#changing-type-encoded-in-the-graph", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class , \n                                                                          Programmer . class }));  TinkerGraph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   types );  fg . addFramedVertex ( Programmer . class );  //make sure the newly added node is actually a programmer  Person   programmer   =   fg . traverse ( g   -   g . V ()). next ( Person . class );  assert   programmer   instanceof   Programmer ;  //change the type resolution to person  programmer . setTypeResolution ( Person . class );  //make sure the newly added node is actually a programmer  Person   person   =   fg . traverse ( g   -   g . V ()). next ( Person . class );  assert   !( person   instanceof   Programmer );", 
            "title": "Changing type encoded in the graph"
        }, 
        {
            "location": "/features/#customizing-how-types-are-encoded", 
            "text": "Set Class ?   types   =   new   HashSet Class ? ( Arrays . asList ( new   Class ? []{ Person . class }));  final   ReflectionCache   cache   =   new   ReflectionCache ( types );  FrameFactory   factory   =   new   AnnotationFrameFactory ( cache );  TypeResolver   resolver   =   new   PolymorphicTypeResolver ( cache ,   customTypeKey );  Graph   g   =   new   TinkerGraph ();  FramedGraph   fg   =   new   DelegatingFramedGraph ( g ,   factory ,   resolver );  fg . addFramedVertex ( Person . class );  Person   person   =   fg . traverse ( g   -   g . V ()). next ( Programmer . class );  String   personClassName   =   Person . class . getName ();  String   encodedClassName   =   person . getProperty ( customTypeKey )  assert   personClassName . equals ( encodedClassName );", 
            "title": "Customizing how types are encoded"
        }, 
        {
            "location": "/object_mapping/", 
            "text": "Ferma is an Object-graph Model (OGM). An Object-graph Model is to a Graph Database as an Object-relational Model (ORM)\nis to a Relational Database. That is to say that it maps Java Objects to edges and vertex in a graph database. As a\nnatural consequence the Java types become an implied Schema for a Graph Database even if the underlying implementation\ndoesnt support the notion of a schema.\n\n\nThe objects associated with the various types of Edges and Vertex in a graph are collectively called the Graph Data\nModel (GDM). Each Java type in the GDM will usually represent a class of Edges or Vertex in underlying graph. All Edges\nin the model will extend from the \nEdgeFrame\n interface and all vertex will extend from \nVertexFrame\n interface. The\nindividual classes that comprise the GDM are usually simply refered to as Frames.\n\n\nThe methods defined by a Frame will represent interactions with the underlying graph via traversals that are relative, \nusing the current edge or vertex as their starting point.\n\n\npublic\n \ninterface\n \nPerson\n \nextends\n \nVertexFrame\n \n{\n\n  \nString\n \ngetName\n();\n\n  \nList\n?\n \nextends\n \nPerson\n \ngetCoworkers\n();\n\n\n}\n\n\n\n\n\nIn this example Person represents a vertex in the graph with a property indicating their name, and they are associated\nwith other vertex in the graph of the same type that represent their coworkers.\n\n\nWhen implementing a vertex as a concrete class you must instead inherit from \nAbstractVertexFrame\n.\n\n\npublic\n \nclass\n \nPerson\n \nextends\n \nAbstractVertexFrame\n \n{\n\n  \npublic\n \nString\n \ngetName\n()\n \n{\n\n      \nreturn\n \nthis\n.\ngetProperty\n(\nname\n);\n\n  \n}\n\n\n  \npublic\n \nList\n?\n \nextends\n \nPerson\n \ngetCoworkers\n()\n \n{\n\n      \nreturn\n \nthis\n.\ntraverse\n(\nv\n \n-\n \nv\n.\nout\n(\ncoworker\n)).\ntoList\n(\nPerson\n.\nclass\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nIt is also possible to do the same with inheritance if you want a class and an interface defined.\n\n\npublic\n \nclass\n \nPersonImpl\n \nextends\n \nAbstractVertexFrame\n \nimplements\n \nPerson\n \n{\n\n  \n@Override\n\n  \npublic\n \nString\n \ngetName\n()\n \n{\n\n      \nreturn\n \nthis\n.\ngetProperty\n(\nname\n);\n\n  \n}\n\n\n  \n@Override\n\n  \npublic\n \nList\n?\n \nextends\n \nPerson\n \ngetCoworkers\n()\n \n{\n\n      \nreturn\n \nthis\n.\ntraverse\n(\nv\n \n-\n \nv\n.\nout\n(\ncoworker\n)).\ntoList\n(\nPerson\n.\nclass\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\nWhen implementing a Frame a class or abstract class must always extend from either \nAbstractEdgeFrame\n or\n\nAbstractVertexFrame\n.\n\n\n\n\nTyping\n\n\nThere are two typing modes for ferma and each significantly effects how the user will determine the type of the objects\npulled from the graph, these modes are called \nTyped Mode\n and \nUntyped Mode\n.\n\n\nWhen performing a traversal on a Frame there are several methods provided which automatically encapsulate the underlying\ngraph element or elements into a framed equivelant such as a \nVertexFrame\n or a \nEdgeFrame\n. This may either be a single\nFrame, \nIterator\n, \nSet\n, or \nList\n of Frames.\n\n\nIn the earlier example we used a traversal to find all the coworkers, we used the \ntoList()\n method to frame all the\nunderlying vertex into the \nPerson\n type.\n\n\nthis\n.\ntraverse\n(\nv\n \n-\n \nv\n.\nout\n(\ncoworker\n)).\ntoList\n(\nPerson\n.\nclass\n);\n\n\n\n\n\nTraversals have several different methods availible that each frame and collect the underlying elements in different\nways, those methods, members of the \nTraversable\n interface, are the following.\n\n\nN\n \nN\n \nnext\n(\nClass\nN\n \nkind\n);\n\n\nN\n \nList\n?\n \nextends\n \nN\n \nnext\n(\nint\n \namount\n,\n \nClass\nN\n \nkind\n);\n\n\nN\n \nN\n \nnextOrDefault\n(\nClass\nN\n \nkind\n,\n \nN\n \ndefaultValue\n);\n\n\nVertexFrame\n \nnextOrAdd\n();\n\n\nN\n \nN\n \nnextOrAdd\n(\nClassInitializer\nN\n \ninitializer\n);\n\n\nN\n \nN\n \nnextOrAdd\n(\nClass\nN\n \nkind\n);\n\n\nN\n \nIterator\nN\n \nframe\n(\nClass\nN\n \nkind\n);\n\n\nN\n \nList\n?\n \nextends\n \nN\n \ntoList\n(\nClass\nN\n \nkind\n);\n\n\nN\n \nSet\n?\n \nextends\n \nN\n \ntoSet\n(\nClass\nN\n \nkind\n);\n\n\n\n\n\n\n\nNote\n\n\nEach of these methods also have an equivelant method with the suffix \nExplicit\n, we will discuss those later as they\nonly become important when we begin to discuss the differences between Typed Mode and \nUntyped Mode\n.\n\n\n\n\nEach of these methods has a slightly different behavior. For full details see the Ferma Javadocs for the Traversable\nclass. However, in short, the \nnext(Class)\n method returns any one of the matching elements and frames it as the\nspecified type. It will throw an exception however if no vertex are found. The \nnextOrDefault\n varient avoids the\nexception by returning the default value when there are no matches, which can be \n0\n or \nnull\n for example. Similarly\n\nnextOrAdd\n will add a new vertex to the underlying graph if the traversal yields no matches. Finally \nframe(Class)\n,\n\ntoList(Class)\n, and \ntoSet(Class)\n will return all elements that match the traversal as either a \nIterator\n, \nList\n, \nor a \nSet\n.\n\n\nThe exact type returned from all the aforementioned calls will always be a Class of the type specified in the argument,\nor a subclass thereof. The exact type of the class instantiated will depend on which typing mode is being used.\n\n\nUntyped Mode\n\n\nIn untyped mode there is never any Java type information encoded into the underlying graph. This means when you take an\nobject off the graph there is no way for Ferma to know what Java type it is associated with and the user must select\nthe type manually. Since a Frame just defines a set of behaviors and properties exposed for a particular graph\nelement it can sometimes be useful to pick which Frame to use to represent an element based on how you need to interact\nwith that element rather than a one to one mapping of element to a specific type. In such a scenario Untyped Mode might\nbe the ideal choice.\n\n\nIn this mode when framing elements from a traversal the type of the element is determined entierly from the parameters\npassed to the methods invoked on the Traversable class. The following is an example of how to frame a vertex as a\n\nPerson\n class from above.\n\n\n// Open an untyped Framed Graph\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\nTinkerGraph\n.\nopen\n());\n\n\n\n//create a vertex with no type information and a single name property\n\n\nVertexFrame\n \nvertex\n \n=\n \nfg\n.\naddFramedVertex\n(\nVertexFrame\n.\nclass\n);\n\n\nvertex\n.\nsetProperty\n(\nname\n,\n \nJeff\n);\n\n\n\n//retrieve the vertex we just created but this time frame it as a Person\n\n\nPerson\n \nperson\n \n=\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n().\nproperty\n(\nname\n,\n \njeff\n)).\nnextExplicit\n(\nPerson\n.\nclass\n);\n\n\nassert\n \nperson\n.\ngetName\n().\nequals\n(\nJeff\n);\n\n\n\n\n\n\n\nNote\n\n\nIn untyped mode all the \nTraversal\n methods with the suffix of \nExplicit\n behave exactly the same as those methods\nwithout the suffix. Therefore when working in untyped mode it is suggested you only use explicit methods. This way\nif you ever decide to migrate over to typed mode it will not change the behavior of your existing code base and will\nmake the migration process much easier. \n\n\n\n\nTyped Mode\n\n\nTyped mode takes things one step further and allows type information about a frame to be encoded as a\nproperty on vertex and edges in the underlying graph. This behavior is governed by the \nPolymorphicTypeResolver\n which\nencodes the type in a property name which defaults to the value of \nPolymorphicTypeResolver.TYPE_RESOLUTION_KEY\n but can\nbe explicitly set to any string value of the user's choice. When a class is framed the Type Resolution Key is read and\nthe original type is determined, this in turn effects the type used to instantiate the new Frame and may be a specific\ntype which is a subclass of the type requested. For example say we have the following model. \n\n\npublic\n \nclass\n \nPerson\n \nextends\n \nAbstractVertexFrame\n \n{\n\n  \npublic\n \nString\n \ngetName\n()\n \n{\n\n      \nreturn\n \nthis\n.\ngetProperty\n(\nname\n);\n\n  \n}\n\n\n  \npublic\n \nList\n?\n \nextends\n \nPerson\n \ngetFriends\n()\n \n{\n\n      \nreturn\n \nthis\n.\ntraverse\n(\nv\n \n-\n \nv\n.\nout\n(\nfriend\n)).\ntoList\n(\nPerson\n.\nclass\n);\n\n  \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nProgrammer\n \nextends\n \nPerson\n \n{\n\n  \n@Override\n\n  \npublic\n \nList\n?\n \nextends\n \nProgrammer\n \ngetFriends\n()\n \n{\n\n      \n//Programmers don\nt have friends :(\n\n      \nreturn\n \nCollections\n.\nemptyList\n();\n\n  \n}\n\n\n}\n\n\n\n\n\nIn this case we can encode a \nProgrammer\n vertex into the graph and even if we try to retrieve and frame that vertex as a\n\nVertexFrame\n or \nPerson\n in the future the instantiated type will still be \nProgrammer\n. This allows for a truly\npolymorphic Graph Data Model that leverages method overriding and class inheritance functiuonality in the model. For\nexample the following is possible now in Typed Mode.\n\n\n// Open a Framed Graph in Typed Mode\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\nTinkerGraph\n.\nopen\n(),\n \ntrue\n,\n \nfalse\n);\n\n\n\n//create a vertex with type information specifying it as the Programmer type\n\n\nProgrammer\n \nprogrammer\n \n=\n \nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n\nprogrammer\n.\nsetName\n(\nJeff\n);\n\n\n\n//retrieve the vertex we just created and check it is instantiated as a Programer\n\n\nPerson\n \nperson\n \n=\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n().\nproperty\n(\nname\n,\n \njeff\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n\nassert\n \nperson\n \ninstanceof\n \nProgrammer\n;\n\n\nassert\n \nperson\n.\ngetFriends\n().\nisEmpty\n();\n\n\n\n\n\nThe methods with the \nExplicit\n suffix are particularly meaningful for Typed Mode. In this mode they bypass the encoded\ntyping completely and instantiate the frame as if in Untyped Mode. The following code snippet provides an\nexample using the same model.\n\n\n// Open typed Framed Graph\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\nTinkerGraph\n.\nopen\n(),\n \ntrue\n,\n \nfalse\n);\n\n\n\n//create a vertex with no type information and a single name property\n\n\nProgrammer\n \nprogrammer\n \n=\n \nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n\nprogrammer\n.\nsetName\n(\nJeff\n);\n\n\n\n//retrieve the vertex we just created, since we are using an excplicit method the type won\nt be Programmer this time.\n\n\nPerson\n \nperson\n \n=\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n().\nproperty\n(\nname\n,\n \njeff\n)).\nnextExplicit\n(\nPerson\n.\nclass\n);\n\n\nassert\n \n!(\nperson\n \ninstanceof\n \nProgrammer\n);\n\n\n\n\n\nThe following are the list of explicit method types in the Traversable class.\n\n\nN\n \nN\n \nnextExplicit\n(\nClass\nN\n \nkind\n);\n\n\nN\n \nList\n?\n \nextends\n \nN\n \nnextExplicit\n(\nint\n \namount\n,\n \nClass\nN\n \nkind\n);\n\n\nN\n \nN\n \nnextOrDefaultExplicit\n(\nClass\nN\n \nkind\n,\n \nN\n \ndefaultValue\n);\n\n\nN\n \nN\n \nnextOrAddExplicit\n(\nClassInitializer\nN\n \ninitializer\n);\n\n\nN\n \nN\n \nnextOrAddExplicit\n(\nClass\nN\n \nkind\n);\n\n\nN\n \nIterator\n?\n \nextends\n \nN\n \nframeExplicit\n(\nClass\nN\n \nkind\n);\n\n\nN\n \nList\n?\n \nextends\n \nN\n \ntoListExplicit\n(\nClass\nN\n \nkind\n);\n\n\nN\n \nSet\n?\n \nextends\n \nN\n \ntoSetExplicit\n(\nClass\nN\n \nkind\n);\n\n\n\n\n\nIt is also possible to change the type encoded in the underlying graph after the element has already been created. The\nfollowing example demonstrates this feature.\n\n\nFramedGraph\n \nfg\n \n=\n \nnew\n \nDelegatingFramedGraph\n(\nTinkerGraph\n.\nopen\n(),\n \ntrue\n,\n \nfalse\n);\n\n\n\n//create a vertex with type information specifying it as the Programmer type\n\n\nProgrammer\n \nprogrammer\n \n=\n \nfg\n.\naddFramedVertex\n(\nProgrammer\n.\nclass\n);\n\n\nprogrammer\n.\nsetName\n(\nJeff\n);\n\n\n\n//retrieve the vertex we just created and check it is instantiated as a Programer\n\n\nPerson\n \nperson\n \n=\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n().\nproperty\n(\nname\n,\n \njeff\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n\nassert\n \nperson\n \ninstanceof\n \nProgrammer\n;\n\n\n\n//change the type resolution to person\n\n\nperson\n.\nsetTypeResolution\n(\nPerson\n.\nclass\n);\n\n\n\n//retrieve the vertex again to show the type changed\n\n\nperson\n \n=\n \nfg\n.\ntraverse\n(\ng\n \n-\n \ng\n.\nV\n().\nproperty\n(\nname\n,\n \njeff\n)).\nnext\n(\nPerson\n.\nclass\n);\n\n\nassert\n(!(\nperson\n \ninstanceof\n \nProgrammer\n));\n\n\nassert\n(\nperson\n \ninstanceof\n \nPerson\n);", 
            "title": "Object Mapping"
        }, 
        {
            "location": "/object_mapping/#typing", 
            "text": "There are two typing modes for ferma and each significantly effects how the user will determine the type of the objects\npulled from the graph, these modes are called  Typed Mode  and  Untyped Mode .  When performing a traversal on a Frame there are several methods provided which automatically encapsulate the underlying\ngraph element or elements into a framed equivelant such as a  VertexFrame  or a  EdgeFrame . This may either be a single\nFrame,  Iterator ,  Set , or  List  of Frames.  In the earlier example we used a traversal to find all the coworkers, we used the  toList()  method to frame all the\nunderlying vertex into the  Person  type.  this . traverse ( v   -   v . out ( coworker )). toList ( Person . class );   Traversals have several different methods availible that each frame and collect the underlying elements in different\nways, those methods, members of the  Traversable  interface, are the following.  N   N   next ( Class N   kind );  N   List ?   extends   N   next ( int   amount ,   Class N   kind );  N   N   nextOrDefault ( Class N   kind ,   N   defaultValue );  VertexFrame   nextOrAdd ();  N   N   nextOrAdd ( ClassInitializer N   initializer );  N   N   nextOrAdd ( Class N   kind );  N   Iterator N   frame ( Class N   kind );  N   List ?   extends   N   toList ( Class N   kind );  N   Set ?   extends   N   toSet ( Class N   kind );    Note  Each of these methods also have an equivelant method with the suffix  Explicit , we will discuss those later as they\nonly become important when we begin to discuss the differences between Typed Mode and  Untyped Mode .   Each of these methods has a slightly different behavior. For full details see the Ferma Javadocs for the Traversable\nclass. However, in short, the  next(Class)  method returns any one of the matching elements and frames it as the\nspecified type. It will throw an exception however if no vertex are found. The  nextOrDefault  varient avoids the\nexception by returning the default value when there are no matches, which can be  0  or  null  for example. Similarly nextOrAdd  will add a new vertex to the underlying graph if the traversal yields no matches. Finally  frame(Class) , toList(Class) , and  toSet(Class)  will return all elements that match the traversal as either a  Iterator ,  List , \nor a  Set .  The exact type returned from all the aforementioned calls will always be a Class of the type specified in the argument,\nor a subclass thereof. The exact type of the class instantiated will depend on which typing mode is being used.", 
            "title": "Typing"
        }, 
        {
            "location": "/object_mapping/#untyped-mode", 
            "text": "In untyped mode there is never any Java type information encoded into the underlying graph. This means when you take an\nobject off the graph there is no way for Ferma to know what Java type it is associated with and the user must select\nthe type manually. Since a Frame just defines a set of behaviors and properties exposed for a particular graph\nelement it can sometimes be useful to pick which Frame to use to represent an element based on how you need to interact\nwith that element rather than a one to one mapping of element to a specific type. In such a scenario Untyped Mode might\nbe the ideal choice.  In this mode when framing elements from a traversal the type of the element is determined entierly from the parameters\npassed to the methods invoked on the Traversable class. The following is an example of how to frame a vertex as a Person  class from above.  // Open an untyped Framed Graph  FramedGraph   fg   =   new   DelegatingFramedGraph ( TinkerGraph . open ());  //create a vertex with no type information and a single name property  VertexFrame   vertex   =   fg . addFramedVertex ( VertexFrame . class );  vertex . setProperty ( name ,   Jeff );  //retrieve the vertex we just created but this time frame it as a Person  Person   person   =   fg . traverse ( g   -   g . V (). property ( name ,   jeff )). nextExplicit ( Person . class );  assert   person . getName (). equals ( Jeff );    Note  In untyped mode all the  Traversal  methods with the suffix of  Explicit  behave exactly the same as those methods\nwithout the suffix. Therefore when working in untyped mode it is suggested you only use explicit methods. This way\nif you ever decide to migrate over to typed mode it will not change the behavior of your existing code base and will\nmake the migration process much easier.", 
            "title": "Untyped Mode"
        }, 
        {
            "location": "/object_mapping/#typed-mode", 
            "text": "Typed mode takes things one step further and allows type information about a frame to be encoded as a\nproperty on vertex and edges in the underlying graph. This behavior is governed by the  PolymorphicTypeResolver  which\nencodes the type in a property name which defaults to the value of  PolymorphicTypeResolver.TYPE_RESOLUTION_KEY  but can\nbe explicitly set to any string value of the user's choice. When a class is framed the Type Resolution Key is read and\nthe original type is determined, this in turn effects the type used to instantiate the new Frame and may be a specific\ntype which is a subclass of the type requested. For example say we have the following model.   public   class   Person   extends   AbstractVertexFrame   { \n   public   String   getName ()   { \n       return   this . getProperty ( name ); \n   } \n\n   public   List ?   extends   Person   getFriends ()   { \n       return   this . traverse ( v   -   v . out ( friend )). toList ( Person . class ); \n   }  }  public   class   Programmer   extends   Person   { \n   @Override \n   public   List ?   extends   Programmer   getFriends ()   { \n       //Programmers don t have friends :( \n       return   Collections . emptyList (); \n   }  }   In this case we can encode a  Programmer  vertex into the graph and even if we try to retrieve and frame that vertex as a VertexFrame  or  Person  in the future the instantiated type will still be  Programmer . This allows for a truly\npolymorphic Graph Data Model that leverages method overriding and class inheritance functiuonality in the model. For\nexample the following is possible now in Typed Mode.  // Open a Framed Graph in Typed Mode  FramedGraph   fg   =   new   DelegatingFramedGraph ( TinkerGraph . open (),   true ,   false );  //create a vertex with type information specifying it as the Programmer type  Programmer   programmer   =   fg . addFramedVertex ( Programmer . class );  programmer . setName ( Jeff );  //retrieve the vertex we just created and check it is instantiated as a Programer  Person   person   =   fg . traverse ( g   -   g . V (). property ( name ,   jeff )). next ( Person . class );  assert   person   instanceof   Programmer ;  assert   person . getFriends (). isEmpty ();   The methods with the  Explicit  suffix are particularly meaningful for Typed Mode. In this mode they bypass the encoded\ntyping completely and instantiate the frame as if in Untyped Mode. The following code snippet provides an\nexample using the same model.  // Open typed Framed Graph  FramedGraph   fg   =   new   DelegatingFramedGraph ( TinkerGraph . open (),   true ,   false );  //create a vertex with no type information and a single name property  Programmer   programmer   =   fg . addFramedVertex ( Programmer . class );  programmer . setName ( Jeff );  //retrieve the vertex we just created, since we are using an excplicit method the type won t be Programmer this time.  Person   person   =   fg . traverse ( g   -   g . V (). property ( name ,   jeff )). nextExplicit ( Person . class );  assert   !( person   instanceof   Programmer );   The following are the list of explicit method types in the Traversable class.  N   N   nextExplicit ( Class N   kind );  N   List ?   extends   N   nextExplicit ( int   amount ,   Class N   kind );  N   N   nextOrDefaultExplicit ( Class N   kind ,   N   defaultValue );  N   N   nextOrAddExplicit ( ClassInitializer N   initializer );  N   N   nextOrAddExplicit ( Class N   kind );  N   Iterator ?   extends   N   frameExplicit ( Class N   kind );  N   List ?   extends   N   toListExplicit ( Class N   kind );  N   Set ?   extends   N   toSetExplicit ( Class N   kind );   It is also possible to change the type encoded in the underlying graph after the element has already been created. The\nfollowing example demonstrates this feature.  FramedGraph   fg   =   new   DelegatingFramedGraph ( TinkerGraph . open (),   true ,   false );  //create a vertex with type information specifying it as the Programmer type  Programmer   programmer   =   fg . addFramedVertex ( Programmer . class );  programmer . setName ( Jeff );  //retrieve the vertex we just created and check it is instantiated as a Programer  Person   person   =   fg . traverse ( g   -   g . V (). property ( name ,   jeff )). next ( Person . class );  assert   person   instanceof   Programmer ;  //change the type resolution to person  person . setTypeResolution ( Person . class );  //retrieve the vertex again to show the type changed  person   =   fg . traverse ( g   -   g . V (). property ( name ,   jeff )). next ( Person . class );  assert (!( person   instanceof   Programmer ));  assert ( person   instanceof   Person );", 
            "title": "Typed Mode"
        }, 
        {
            "location": "/annotations/overview/", 
            "text": "The Ferma schema is defined by a collection of interfaces and classes written by the user. Each method will interact\nwith the underlying graph to either modify the graph in some way, or to retrieve an element or property from the graph.\nThere are two techniques for defining how these methods behave. Either you can explicitly implement the method, or you\ncan leave the method as abstract and annotate the method in order to allow Ferma to implement the method for you. Here\nwe will define the annotations available to you and how they work, along with a few examples.\n\n\nThe behavior of an annotated method is dictated not only by the annotation applied to it but also the method's\nsignature. Therefore an annotated method will behave differently if it's return type, arguments, or even if the method\nname were to change. It is important to note that when a method is explicitly defined (doesnt use an annotation) then\nthe method signature can be anything.\n\n\nMethod names that are annotated must have one of the following prefixes: add, get, remove, set, is. Exactly which \nprefixes are varies from one annotation to the next so see the annotations detailed documentation to make that\ndetermination. It is also possible to override this behavior by setting the operation argument availible on most\nannotations which defaults to \nAUTO\n when not specified.", 
            "title": "Overview"
        }, 
        {
            "location": "/annotations/adjacency/", 
            "text": "Valid on frames: \nVertex\n\n\nAllowed prefixes when operation is AUTO: \nadd\n, \nget\n, \nremove\n, \nset\n\n\nAnnotation arguments:\n\n\nlabel\n - The label assigned to the edge which connects the adjacent nodes.\n\n\ndirection\n - The direction for the edge which creates the adjacency. It can be assigned any of the values from\n              \norg.apache.tinkerpop.gremlin.structure.Direction\n.\n\n\noperation\n - The operation the method will perform. Must be one of the following: \nGET\n, \nADD\n, \nSET\n, \nREMOVE\n,\n              \nAUTO\n. Defaults to \nAUTO\n.\n\n\nexample:\n\n\n@Adjacency\n(\nfoo\n)\n\n\n//Method declared here\n\n\n\n\n\nADD Operation\n\n\nValid method signatures: \n( )\n, \n(VertexFrame)\n, \n(ClassInitializer)\n, \n(ClassInitializer, ClassInitializer)\n,\n\n(VertexFrame, ClassInitializer)\n\n\nAdds a node as an adjacency to the current node, and the returns the newly connected node.\n\n\nSignature: \n( )\n\n\nValid return types: \nVertexFrame\n\n\nCreates a new vertex without any type information as well as an untyped edge to connect to it. The newly created\n\nVertexFrame\n is returned.\n\n\n\n\nNote\n\n\nSince the returned \nVertexFrame\n is always untyped the return type must be either \nVertexFrame\n or \nTVertex\n\nspecifically.\n\n\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nVertexFrame\n \naddFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nVertexFrame\n \nincludeFoobar\n();\n\n\n\n\n\nSignature: \n(VertexFrame)\n\n\nValid return types: \nVertexFrame\n or \nvoid\n\n\nCreates a new edge without any type information and connects it between this vertex the vertex specified as an argument\nto the method. The frame returned is the same as the frame given in the argument, it is only there for compatability\nwith other add methods. This method can also have a \nvoid\n return type.\n\n\nexamples:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \naddFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \naddFoobar\n(\nE\n \nexistingVertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \naddFoobar\n(\nE\n \nexistingVertex\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nvoid\n \nincludeFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\nSignature: \n(ClassInitializer)\n\n\nValid return types: \nVertexFrame\n\n\nCreates a new edge without any type information and connects it between this vertex and a newly created vertex. The\nnewly created vertex will have a type, as well as be initiated, according to the details specified in the\nClassInitializer argument. Java generics can, and should, be used to narrow the return type.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nE\n \nvertexInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nE\n \nvertexInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nBarVertex\n \nincludeFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n);\n\n\n\n\n\nSignature: \n(ClassInitializer, ClassInitializer)\n\n\nValid return types: \nVertexFrame\n\n\nCreates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be\ninitiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge\nwill hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                    \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nE\n \nvertexInitializer\n,\n\n                                  \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nE\n \nvertexInitializer\n,\n\n                                    \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nBarVertex\n \nincludeFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                        \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\nSignature: \n(VertexFrame, ClassInitializer)\n\n\nValid return types: \nVertexFrame\n or \nvoid\n\n\nCreates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be\ninitiated, according to the details specified in the \nClassInitializer\n argument. The \nVertexFrame\n specified in the first\nargument will simply be returned. A \nvoid\n return type is also valid. Java generics can, and should, be used\nto narrow the return type as well as to restrict the \nClassInitializer\n.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \naddFoobar\n(\nBarVertex\n \nvertex\n,\n\n                    \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \naddFoobar\n(\nE\n \nvertex\n,\n\n                                  \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \naddFoobar\n(\nBarVertex\n \nvertex\n,\n\n                                    \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nvoid\n \nincludeFoobar\n(\nBarVertex\n \nvertex\n,\n\n                        \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\nGET Operation\n\n\nValid method signatures: \n()\n, \n(Class)\n\n\nGet's one or more adjacent vertex from the graph.\n\n\nSignature: \n( )\n\n\nValid return types: \nVertexFrame\n or \nIterator\n or \nList\n or \nSet\n\n\nRetrieves one or more of the adjacent edges. If the return type is a single Frame then only the first instance is\nreturned. If the return type is an \nIterator\n or \nList\n or \nSet\n then it will supply all matching vertex. When using an\n\nIterator\n or \nList\n or \nSet\n it is encouraged, but not required, to use generics. The returned frames will always be\ninstantiated as the type encoded in the graph if there is one.\n\n\n\n\nNote\n\n\nIf a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown.\nTherefore the return type specifed should always by the same type, or a superclass, of the expected return type.\nVertexFrame is always a safe return type for this method.\n\n\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nIterator\nBarVertex\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nIterator\nE\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nIterator\nE\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nList\nBarVertex\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nSet\nBarVertex\n \ngetFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nGET\n)\n\n\nBarVertex\n \nobtainFoobar\n();\n\n\n\n\n\nSignature: \n(Class)\n\n\nValid return types: \nVertexFrame\n or \nIterator\n or \nList\n or \nSet\n\n\nRetrieves one or more of the adjacent vertex. If the return type is a single \nVertexFrame\n then only the first instance\nis returned. If the return type is an \nIterator\n then it will iterate over all matching vertex. When using an Iterator\nit is encouraged to use generics.\n\n\n\n\nNote\n\n\nThe Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype,\nto that of the argument will be returned.\n\n\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nBarVertex\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nBarVertex\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nIterator\nBarVertex\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nBarVertex\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nIterator\nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nIterator\nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nList\nBarVertex\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nBarVertex\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nSet\nBarVertex\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nBarVertex\n \nfilter\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nGET\n)\n\n\nBarVertex\n \nobtainFoobar\n(\nClass\n?\n \nextends\n \nBarVertex\n \nfilter\n);\n\n\n\n\n\nREMOVE Operation\n\n\nValid method signatures: \n( )\n, \n(VertexFrame)\n\n\nRemoves any edges which cause an adjacency, leaving the vertex in place.\n\n\nSignature: \n( )\n\n\nValid return types: \nvoid\n\n\nRemoves all edges which create any adjacency between the current vertex and any other vertex using the specified label.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nremoveFoobar\n();\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nREMOVE\n)\n\n\nvoid\n \ndeleteAllFoobar\n(\nE\n \nvertex\n);\n\n\n\n\n\nSignature: \n(VertexFrame)\n\n\nValid return types: \nvoid\n\n\nRemoves all edges which create an adjacency between the current vertex and the vertex specified in the methods argument\nand has the specified label.\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nremoveFoobar\n(\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nE\n \nextends\n \nBarVertex\n \nvoid\n \nremoveFoobar\n(\nE\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nvoid\n \nremoveFoobar\n(\nE\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nREMOVE\n)\n\n\nvoid\n \nremoveFoobar\n(\nBarVertex\n \nvertex\n);\n\n\n\n\n\nSET Operation\n\n\nValid method signatures: \n(VertexFrame)\n, \n(Iterator)\n, \n(Iterable)\n\n\nCreates new edges connected to several vertex and at the same time removes any existing edges. If the any of the vertex\nbeing set are already an adjacency then the edge will still be removed and recreated.\n\n\n\n\nWarning\n\n\nThe set operation methods are equivelant to removing all existing edges of the specified label and direction\nconnected to the current vertex and then call add on all the vertex specified by the method's parameters. You will\nloose any existing properties set on all dropped edges as well.\n\n\n\n\nSignature: \n(VertexFrame)\n\n\nValid return types: \nvoid\n\n\nThe argument for this method must be a \nVertexFrame\n or a class or interface which inherits from that class.\n\n\nThis method will drop all existing edges with the specified label and create a single new edge to the vertex specified.\nOf course if the direction is set to both then two new edges are created instead, one in each direction. Any newly\ncreated edges will not encode a type.\n\n\n\n\nWarning\n\n\nIf the vertex specified in the method's argument already has an edge forming an adjacency with this vertex and has\nmatching direction and label attributes then that edge will be removed and recreated as a blank untyped edge with\nthe same label.\n\n\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nBarVertex\n \nvoid\n \nsetFoobar\n(\nE\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nSET\n)\n\n\nvoid\n \nassignFoobar\n(\nBarVertex\n \nvertex\n);\n\n\n\n\n\nSignature: \n(Iterator)\n\n\nValid return types: \nvoid\n\n\nThe argument for this method must be an \nIterator\n which iterates over Vertex Frames. It is suggested you specify a\nGeneric Type for the Iterator for usability.\n\n\nThis method will drop all existing edges with the specified lable then iterate over all the vertex specified in the\n\nIterator\n argument and create new edges to connect to them. The edges in the graph will not encode a type.\n\n\n\n\nWarning\n\n\nIf any of the vertex specified by this method's argument already has an edge forming an adjacency with this vertex\nand has matching direction and label attributes then that edge will be removed and recreated as a blank untyped edge\nwith the same label.\n\n\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nIterator\nBarVertexr\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nBarVertex\n \nvoid\n \nsetFoobar\n(\nIterator\n?\n \nextends\n \nE\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nSET\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nvoid\n \nincludeFoobar\n(\nIterator\n?\n \nextends\n \nE\n \nvertex\n);\n\n\n\n\n\nSignature: \n(Iterable)\n\n\nValid return types: \nvoid\n\n\nThe argument for this method must be an \nIterable\n or a subclass of \nIterable\n which iterates over vertex Frames. It is\nsuggested you specify a Generic Type for the Iterator for usability. Since all Java collections inherit from the\n\nIterable\n interface any collection type can also be used as a parameter to this methods.\n\n\nThis method will drop all existing edges with the specified lable then iterate over all the vertex specified in the\n\nIterable\n argument and create new edges to connect to them. The edges in the graph will not encode a type.\n\n\n\n\nWarning\n\n\nIf any of the vertex specified by this method's argument already has an edge forming an adjacency with this vertex\nand has matching direction and label attributes then that edge will be removed and recreated as a blank untyped edge\nwith the same label.\n\n\n\n\nexample:\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nIterable\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nCollection\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nList\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nSet\nBarVertex\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nBarVertex\n \nvoid\n \nsetFoobar\n(\nIterable\n?\n \nextends\n \nE\n \nvertex\n);\n\n\n\n\n\n@Adjacency\n(\nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nSET\n)\n\n\nE\n \nextends\n \nVertexFrame\n \nvoid\n \nincludeFoobar\n(\nIterable\n?\n \nextends\n \nE\n \nvertex\n);", 
            "title": "@Adjacency"
        }, 
        {
            "location": "/annotations/adjacency/#add-operation", 
            "text": "Valid method signatures:  ( ) ,  (VertexFrame) ,  (ClassInitializer) ,  (ClassInitializer, ClassInitializer) , (VertexFrame, ClassInitializer)  Adds a node as an adjacency to the current node, and the returns the newly connected node.", 
            "title": "ADD Operation"
        }, 
        {
            "location": "/annotations/adjacency/#signature", 
            "text": "Valid return types:  VertexFrame  Creates a new vertex without any type information as well as an untyped edge to connect to it. The newly created VertexFrame  is returned.   Note  Since the returned  VertexFrame  is always untyped the return type must be either  VertexFrame  or  TVertex \nspecifically.   example:  @Adjacency ( Foo )  VertexFrame   addFoobar ();   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  VertexFrame   includeFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/adjacency/#signature-vertexframe", 
            "text": "Valid return types:  VertexFrame  or  void  Creates a new edge without any type information and connects it between this vertex the vertex specified as an argument\nto the method. The frame returned is the same as the frame given in the argument, it is only there for compatability\nwith other add methods. This method can also have a  void  return type.  examples:  @Adjacency ( Foo )  BarVertex   addFoobar ( BarVertex   existingVertex );   @Adjacency ( Foo )  E   extends   BarVertex   E   addFoobar ( E   existingVertex );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   VertexFrame   E   addFoobar ( E   existingVertex );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  void   includeFoobar ( BarVertex   existingVertex );", 
            "title": "Signature: (VertexFrame)"
        }, 
        {
            "location": "/annotations/adjacency/#signature-classinitializer", 
            "text": "Valid return types:  VertexFrame  Creates a new edge without any type information and connects it between this vertex and a newly created vertex. The\nnewly created vertex will have a type, as well as be initiated, according to the details specified in the\nClassInitializer argument. Java generics can, and should, be used to narrow the return type.  example:  @Adjacency ( Foo )  BarVertex   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer );   @Adjacency ( Foo )  E   extends   BarVertex   E   addFoobar ( ClassInitializer ?   extends   E   vertexInitializer );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   VertexFrame   E   addFoobar ( ClassInitializer ?   extends   E   vertexInitializer );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  BarVertex   includeFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer );", 
            "title": "Signature: (ClassInitializer)"
        }, 
        {
            "location": "/annotations/adjacency/#signature-classinitializer-classinitializer", 
            "text": "Valid return types:  VertexFrame  Creates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be\ninitiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge\nwill hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type.  example:  @Adjacency ( Foo )  BarVertex   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                     ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( Foo )  E   extends   BarVertex   E   addFoobar ( ClassInitializer ?   extends   E   vertexInitializer , \n                                   ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   VertexFrame   E   addFoobar ( ClassInitializer ?   extends   E   vertexInitializer , \n                                     ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  BarVertex   includeFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                         ClassInitializer ?   extends   FooEdge   edgeInitializer );", 
            "title": "Signature: (ClassInitializer, ClassInitializer)"
        }, 
        {
            "location": "/annotations/adjacency/#signature-vertexframe-classinitializer", 
            "text": "Valid return types:  VertexFrame  or  void  Creates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be\ninitiated, according to the details specified in the  ClassInitializer  argument. The  VertexFrame  specified in the first\nargument will simply be returned. A  void  return type is also valid. Java generics can, and should, be used\nto narrow the return type as well as to restrict the  ClassInitializer .  example:  @Adjacency ( Foo )  BarVertex   addFoobar ( BarVertex   vertex , \n                     ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( Foo )  E   extends   BarVertex   E   addFoobar ( E   vertex , \n                                   ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   VertexFrame   E   addFoobar ( BarVertex   vertex , \n                                     ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  void   includeFoobar ( BarVertex   vertex , \n                         ClassInitializer ?   extends   FooEdge   edgeInitializer );", 
            "title": "Signature: (VertexFrame, ClassInitializer)"
        }, 
        {
            "location": "/annotations/adjacency/#get-operation", 
            "text": "Valid method signatures:  () ,  (Class)  Get's one or more adjacent vertex from the graph.", 
            "title": "GET Operation"
        }, 
        {
            "location": "/annotations/adjacency/#signature_1", 
            "text": "Valid return types:  VertexFrame  or  Iterator  or  List  or  Set  Retrieves one or more of the adjacent edges. If the return type is a single Frame then only the first instance is\nreturned. If the return type is an  Iterator  or  List  or  Set  then it will supply all matching vertex. When using an Iterator  or  List  or  Set  it is encouraged, but not required, to use generics. The returned frames will always be\ninstantiated as the type encoded in the graph if there is one.   Note  If a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown.\nTherefore the return type specifed should always by the same type, or a superclass, of the expected return type.\nVertexFrame is always a safe return type for this method.   example:  @Adjacency ( Foo )  BarVertex   getFoobar ();   @Adjacency ( Foo )  E   extends   BarVertex   E   getFoobar ();   @Adjacency ( Foo )  E   extends   VertexFrame   E   getFoobar ();   @Adjacency ( Foo )  Iterator BarVertex   getFoobar ();   @Adjacency ( Foo )  E   extends   BarVertex   Iterator E   getFoobar ();   @Adjacency ( Foo )  E   extends   VertexFrame   Iterator E   getFoobar ();   @Adjacency ( Foo )  List BarVertex   getFoobar ();   @Adjacency ( Foo ,   direction   =   Direction . IN )  Set BarVertex   getFoobar ();   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . GET )  BarVertex   obtainFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/adjacency/#signature-class", 
            "text": "Valid return types:  VertexFrame  or  Iterator  or  List  or  Set  Retrieves one or more of the adjacent vertex. If the return type is a single  VertexFrame  then only the first instance\nis returned. If the return type is an  Iterator  then it will iterate over all matching vertex. When using an Iterator\nit is encouraged to use generics.   Note  The Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype,\nto that of the argument will be returned.   example:  @Adjacency ( Foo )  BarVertex   getFoobar ( Class ?   extends   BarVertex   filter );   @Adjacency ( Foo )  E   extends   BarVertex   E   getFoobar ( Class ?   extends   E   filter );   @Adjacency ( Foo )  E   extends   VertexFrame   E   getFoobar ( Class ?   extends   E   filter );   @Adjacency ( Foo )  Iterator BarVertex   getFoobar ( Class ?   extends   BarVertex   filter );   @Adjacency ( Foo )  E   extends   BarVertex   Iterator E   getFoobar ( Class ?   extends   E   filter );   @Adjacency ( Foo )  E   extends   VertexFrame   Iterator E   getFoobar ( Class ?   extends   E   filter );   @Adjacency ( Foo )  List BarVertex   getFoobar ( Class ?   extends   BarVertex   filter );   @Adjacency ( Foo ,   direction   =   Direction . IN )  Set BarVertex   getFoobar ( Class ?   extends   BarVertex   filter );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . GET )  BarVertex   obtainFoobar ( Class ?   extends   BarVertex   filter );", 
            "title": "Signature: (Class)"
        }, 
        {
            "location": "/annotations/adjacency/#remove-operation", 
            "text": "Valid method signatures:  ( ) ,  (VertexFrame)  Removes any edges which cause an adjacency, leaving the vertex in place.", 
            "title": "REMOVE Operation"
        }, 
        {
            "location": "/annotations/adjacency/#signature_2", 
            "text": "Valid return types:  void  Removes all edges which create any adjacency between the current vertex and any other vertex using the specified label.  example:  @Adjacency ( Foo )  void   removeFoobar ();   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . REMOVE )  void   deleteAllFoobar ( E   vertex );", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/adjacency/#signature-vertexframe_1", 
            "text": "Valid return types:  void  Removes all edges which create an adjacency between the current vertex and the vertex specified in the methods argument\nand has the specified label.  example:  @Adjacency ( Foo )  void   removeFoobar ( BarVertex   vertex );   @Adjacency ( Foo )  E   extends   BarVertex   void   removeFoobar ( E   vertex );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   VertexFrame   void   removeFoobar ( E   vertex );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . REMOVE )  void   removeFoobar ( BarVertex   vertex );", 
            "title": "Signature: (VertexFrame)"
        }, 
        {
            "location": "/annotations/adjacency/#set-operation", 
            "text": "Valid method signatures:  (VertexFrame) ,  (Iterator) ,  (Iterable)  Creates new edges connected to several vertex and at the same time removes any existing edges. If the any of the vertex\nbeing set are already an adjacency then the edge will still be removed and recreated.   Warning  The set operation methods are equivelant to removing all existing edges of the specified label and direction\nconnected to the current vertex and then call add on all the vertex specified by the method's parameters. You will\nloose any existing properties set on all dropped edges as well.", 
            "title": "SET Operation"
        }, 
        {
            "location": "/annotations/adjacency/#signature-vertexframe_2", 
            "text": "Valid return types:  void  The argument for this method must be a  VertexFrame  or a class or interface which inherits from that class.  This method will drop all existing edges with the specified label and create a single new edge to the vertex specified.\nOf course if the direction is set to both then two new edges are created instead, one in each direction. Any newly\ncreated edges will not encode a type.   Warning  If the vertex specified in the method's argument already has an edge forming an adjacency with this vertex and has\nmatching direction and label attributes then that edge will be removed and recreated as a blank untyped edge with\nthe same label.   example:  @Adjacency ( Foo )  void   setFoobar ( BarVertex   vertex );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   BarVertex   void   setFoobar ( E   vertex );   @Adjacency ( value   =   Foo ,   operation   =   Adjacency . Operation . SET )  void   assignFoobar ( BarVertex   vertex );", 
            "title": "Signature: (VertexFrame)"
        }, 
        {
            "location": "/annotations/adjacency/#signature-iterator", 
            "text": "Valid return types:  void  The argument for this method must be an  Iterator  which iterates over Vertex Frames. It is suggested you specify a\nGeneric Type for the Iterator for usability.  This method will drop all existing edges with the specified lable then iterate over all the vertex specified in the Iterator  argument and create new edges to connect to them. The edges in the graph will not encode a type.   Warning  If any of the vertex specified by this method's argument already has an edge forming an adjacency with this vertex\nand has matching direction and label attributes then that edge will be removed and recreated as a blank untyped edge\nwith the same label.   example:  @Adjacency ( Foo )  void   setFoobar ( Iterator BarVertexr   vertex );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   BarVertex   void   setFoobar ( Iterator ?   extends   E   vertex );   @Adjacency ( Foo ,   operation   =   Adjacency . Operation . SET )  E   extends   VertexFrame   void   includeFoobar ( Iterator ?   extends   E   vertex );", 
            "title": "Signature: (Iterator)"
        }, 
        {
            "location": "/annotations/adjacency/#signature-iterable", 
            "text": "Valid return types:  void  The argument for this method must be an  Iterable  or a subclass of  Iterable  which iterates over vertex Frames. It is\nsuggested you specify a Generic Type for the Iterator for usability. Since all Java collections inherit from the Iterable  interface any collection type can also be used as a parameter to this methods.  This method will drop all existing edges with the specified lable then iterate over all the vertex specified in the Iterable  argument and create new edges to connect to them. The edges in the graph will not encode a type.   Warning  If any of the vertex specified by this method's argument already has an edge forming an adjacency with this vertex\nand has matching direction and label attributes then that edge will be removed and recreated as a blank untyped edge\nwith the same label.   example:  @Adjacency ( Foo )  void   setFoobar ( Iterable BarVertex   vertex );   @Adjacency ( Foo )  void   setFoobar ( Collection BarVertex   vertex );   @Adjacency ( Foo )  void   setFoobar ( List BarVertex   vertex );   @Adjacency ( Foo )  void   setFoobar ( Set BarVertex   vertex );   @Adjacency ( Foo ,   direction   =   Direction . IN )  E   extends   BarVertex   void   setFoobar ( Iterable ?   extends   E   vertex );   @Adjacency ( Foo ,   operation   =   Adjacency . Operation . SET )  E   extends   VertexFrame   void   includeFoobar ( Iterable ?   extends   E   vertex );", 
            "title": "Signature: (Iterable)"
        }, 
        {
            "location": "/annotations/graphelement/", 
            "text": "Valid on frames: \nEdge\n and \nvertex\n\n\nThe \n@GraphElement\n annotation takes no parameters and is placed before your class decleration on an \nEdgeFrame\n or\n\nVertexFrame\n. This annotation is mostly leveraged right now when scanning classes in a package to identify frames.\n\n\nexample:\n\n\n@GraphElement\n\n\npublic\n \ninterface\n \nFooVertex\n \nextends\n \nVertexFrame\n \n{\n\n    \n//Methods goes here\n\n\n}", 
            "title": "@GraphElement"
        }, 
        {
            "location": "/annotations/incidence/", 
            "text": "Valid on frames: \nVertex\n\n\nAllowed prefixes when operation is AUTO: \nadd\n, \nget\n, \nremove\n\n\nAnnotation arguments:\n\n\nlabel\n - The label assigned to the edge which connects the adjacent nodes.\n\n\ndirection\n - The direction for the edge which creates the adjacency. It can be assigned any of the values from\n              \norg.apache.tinkerpop.gremlin.structure.Direction\n.\n\n\noperation\n - The operation the method will perform. Must be one of the following: \nGET\n, \nADD\n, \nSET\n, \nREMOVE\n,\n              \nAUTO\n. Defaults to \nAUTO\n.\n\n\nexample:\n\n\n@Incidence\n(\nfoo\n)\n\n\n//Method declared here\n\n\n\n\n\nADD Operation\n\n\nValid method signatures: \n( )\n, \n(VertexFrame)\n, \n(ClassInitializer)\n, \n(VertexFrame, ClassInitializer)\n,\n\n(ClassInitializer, ClassInitializer)\n\n\nAdds an edge to edge to a node and returns the new \nEdgeFrame\n.\n\n\nSignature: \n( )\n\n\nValid return types: \nEdgeFrame\n\n\nCreates a new vertex without any type information as well as an untyped edge to connect to it. The newly created\n\nTEdge\n is returned.\n\n\n\n\nNote\n\n\nSince the returned \nVertexFrame\n is always untyped the return type must be either \nVertexFrame\n or \nTVertex\n\nspecifically.\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nEdgeFrame\n \naddFoobar\n();\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nTEdge\n \naddFoobar\n();\n\n\n\n\n\nSignature: \n(VertexFrame)\n\n\nValid return types: \nEdgeFrame\n\n\nCreates a new edge without any type information and connects it between this vertex the vertex specified as an argument\nto the method. The frame returned is the newly created \nTEdge\n.\n\n\nexamples:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \naddFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \naddFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nEdgeFrame\n \naddFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nE\n \naddFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nFooEdge\n \nincludeFoobar\n(\nBarVertex\n \nexistingVertex\n);\n\n\n\n\n\nSignature: \n(ClassInitializer)\n\n\nValid return types: \nEdgeFrame\n\n\nCreates a new edge without any type information and connects it between this vertex and a newly created vertex. The\nnewly created vertex will have a type, as well as be initiated, according to the details specified in the\nClassInitializer argument. Java generics can, and should, be used to narrow the return type. The returned object will be\nthe newly created \nTEdge\n.\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nFooEdge\n \nvertexInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nTEdge\n \nincludeFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n);\n\n\n\n\n\nSignature: \n(VertexFrame, ClassInitializer)\n\n\nValid return types: \nEdgeFrame\n\n\nCreates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be\ninitiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type. The returned object will be the newly created \nEdgeFrame\n.\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \naddFoobar\n(\nBarVertex\n \nbar\n,\n\n                  \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \naddFoobar\n(\nBarVertex\n \nbar\n,\n\n                                \nClassInitializer\n?\n \nextends\n \nE\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nE\n \naddFoobar\n(\nVertexFrame\n \nvertex\n,\n\n                                  \nClassInitializer\n?\n \nextends\n \nE\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nFooEdge\n \nincludeFoobar\n(\nBarVertex\n \nbar\n,\n\n                      \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\nSignature: \n(ClassInitializer, ClassInitializer)\n\n\nValid return types: \nEdgeFrame\n\n\nCreates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be\ninitiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge\nwill hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type. The returned object will be the newly created \nEdgeFrame\n.\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                    \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                                  \nClassInitializer\n?\n \nextends\n \nE\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nE\n \naddFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                                  \nClassInitializer\n?\n \nextends\n \nE\n \nedgeInitializer\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nADD\n)\n\n\nFooEdge\n \nincludeFoobar\n(\nClassInitializer\n?\n \nextends\n \nBarVertex\n \nvertexInitializer\n,\n\n                      \nClassInitializer\n?\n \nextends\n \nFooEdge\n \nedgeInitializer\n);\n\n\n\n\n\nGET Operation\n\n\nValid method signatures: \n()\n, \n(Class)\n\n\nGet's one or more adjacent edgesd from the graph.\n\n\nSignature: \n( )\n\n\nValid return types: \nVertexFrame\n or \nIterator\n or \nList\n or \nSet\n\n\nRetrieves one or more of the adjacent vertex. If the return type is a single Frame then only the first instance is\nreturned. If the return type is an \nIterator\n or \nList\n or \nSet\n then it will supply all matching edges. When using an\n\nIterator\n or \nList\n or \nSet\n it is encouraged, but not required, to use generics. The returned frames will always be\ninstantiated as the type encoded in the graph if there is one.\n\n\n\n\nNote\n\n\nIf a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown.\nTherefore the return type specifed should always by the same type, or a superclass, of the expected return type.\nVertexFrame is always a safe return type for this method.\n\n\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nIterator\nFooEdge\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nIterator\nE\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nIterator\nE\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nList\nFooEdge\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nSet\nFooEdge\n \ngetFoobar\n();\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nGET\n)\n\n\nFooEdge\n \nobtainFoobar\n();\n\n\n\n\n\nSignature: \n(Class)\n\n\nValid return types: \nVertexFrame\n or \nIterator\n or \nList\n or \nSet\n\n\nRetrieves one or more of the adjacent edges. If the return type is a single \nEdgeFrame\n then only the first instance\nis returned. If the return type is an \nIterator\n then it will iterate over all matching vertex. When using an Iterator\nit is encouraged to use generics.\n\n\n\n\nNote\n\n\nThe Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype,\nto that of the argument will be returned.\n\n\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nFooEdge\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nFooEdge\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nIterator\nFooEdge\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nFooEdge\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nIterator\nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nIterator\nE\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nE\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nList\nFooEdge\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nFooEdge\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nSet\nFooEdge\n \ngetFoobar\n(\nClass\n?\n \nextends\n \nFooEdge\n \nfilter\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nGET\n)\n\n\nFooEdge\n \nobtainFoobar\n(\nClass\n?\n \nextends\n \nFooEdge\n \nfilter\n);\n\n\n\n\n\nREMOVE Operation\n\n\nValid method signatures: \n(EdgeFrame)\n\n\nRemoves an edges which cause an adjacency, leaving the vertex in place.\n\n\nSignature: \n(EdgeFrame)\n\n\nValid return types: \nvoid\n\n\nRemoves the edge specified in the argument. This is entirely equivelant to just calling the \nremove()\n method on the\n\nEdgeFrame\n\n\nexample:\n\n\n@Incidence\n(\nFoo\n)\n\n\nvoid\n \nremoveFoobar\n(\nFooEdge\n \nedge\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n)\n\n\nE\n \nextends\n \nFooEdge\n \nvoid\n \nremoveFoobar\n(\nE\n \nedge\n);\n\n\n\n\n\n@Incidence\n(\nFoo\n,\n \ndirection\n \n=\n \nDirection\n.\nIN\n)\n\n\nE\n \nextends\n \nEdgeFrame\n \nvoid\n \nremoveFoobar\n(\nE\n \nedge\n);\n\n\n\n\n\n@Incidence\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nAdjacency\n.\nOperation\n.\nREMOVE\n)\n\n\nvoid\n \nremoveFoobar\n(\nFooEdge\n \nedge\n);", 
            "title": "@Incidence"
        }, 
        {
            "location": "/annotations/incidence/#add-operation", 
            "text": "Valid method signatures:  ( ) ,  (VertexFrame) ,  (ClassInitializer) ,  (VertexFrame, ClassInitializer) , (ClassInitializer, ClassInitializer)  Adds an edge to edge to a node and returns the new  EdgeFrame .", 
            "title": "ADD Operation"
        }, 
        {
            "location": "/annotations/incidence/#signature", 
            "text": "Valid return types:  EdgeFrame  Creates a new vertex without any type information as well as an untyped edge to connect to it. The newly created TEdge  is returned.   Note  Since the returned  VertexFrame  is always untyped the return type must be either  VertexFrame  or  TVertex \nspecifically.   @Incidence ( Foo )  EdgeFrame   addFoobar ();   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  TEdge   addFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/incidence/#signature-vertexframe", 
            "text": "Valid return types:  EdgeFrame  Creates a new edge without any type information and connects it between this vertex the vertex specified as an argument\nto the method. The frame returned is the newly created  TEdge .  examples:  @Incidence ( Foo )  FooEdge   addFoobar ( BarVertex   existingVertex );   @Incidence ( Foo )  E   extends   FooEdge   E   addFoobar ( BarVertex   existingVertex );   @Incidence ( Foo )  EdgeFrame   addFoobar ( BarVertex   existingVertex );   @Incidence ( Foo ,   direction   =   Direction . IN )  E   extends   EdgeFrame   E   addFoobar ( BarVertex   existingVertex );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  FooEdge   includeFoobar ( BarVertex   existingVertex );", 
            "title": "Signature: (VertexFrame)"
        }, 
        {
            "location": "/annotations/incidence/#signature-classinitializer", 
            "text": "Valid return types:  EdgeFrame  Creates a new edge without any type information and connects it between this vertex and a newly created vertex. The\nnewly created vertex will have a type, as well as be initiated, according to the details specified in the\nClassInitializer argument. Java generics can, and should, be used to narrow the return type. The returned object will be\nthe newly created  TEdge .  example:  @Incidence ( Foo )  FooEdge   addFoobar ( ClassInitializer ?   extends   FooEdge   vertexInitializer );   @Incidence ( Foo )  E   extends   FooEdge   E   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer );   @Incidence ( Foo ,   direction   =   Direction . IN )  E   extends   FooEdge   E   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  TEdge   includeFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer );", 
            "title": "Signature: (ClassInitializer)"
        }, 
        {
            "location": "/annotations/incidence/#signature-vertexframe-classinitializer", 
            "text": "Valid return types:  EdgeFrame  Creates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be\ninitiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type. The returned object will be the newly created  EdgeFrame .  example:  @Incidence ( Foo )  FooEdge   addFoobar ( BarVertex   bar , \n                   ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Incidence ( Foo )  E   extends   FooEdge   E   addFoobar ( BarVertex   bar , \n                                 ClassInitializer ?   extends   E   edgeInitializer );   @Incidence ( Foo ,   direction   =   Direction . IN )  E   extends   EdgeFrame   E   addFoobar ( VertexFrame   vertex , \n                                   ClassInitializer ?   extends   E   edgeInitializer );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  FooEdge   includeFoobar ( BarVertex   bar , \n                       ClassInitializer ?   extends   FooEdge   edgeInitializer );", 
            "title": "Signature: (VertexFrame, ClassInitializer)"
        }, 
        {
            "location": "/annotations/incidence/#signature-classinitializer-classinitializer", 
            "text": "Valid return types:  EdgeFrame  Creates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be\ninitiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge\nwill hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used\nto narrow the return type. The returned object will be the newly created  EdgeFrame .  example:  @Incidence ( Foo )  FooEdge   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                     ClassInitializer ?   extends   FooEdge   edgeInitializer );   @Incidence ( Foo )  E   extends   FooEdge   E   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                                   ClassInitializer ?   extends   E   edgeInitializer );   @Incidence ( Foo ,   direction   =   Direction . IN )  E   extends   EdgeFrame   E   addFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                                   ClassInitializer ?   extends   E   edgeInitializer );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . ADD )  FooEdge   includeFoobar ( ClassInitializer ?   extends   BarVertex   vertexInitializer , \n                       ClassInitializer ?   extends   FooEdge   edgeInitializer );", 
            "title": "Signature: (ClassInitializer, ClassInitializer)"
        }, 
        {
            "location": "/annotations/incidence/#get-operation", 
            "text": "Valid method signatures:  () ,  (Class)  Get's one or more adjacent edgesd from the graph.", 
            "title": "GET Operation"
        }, 
        {
            "location": "/annotations/incidence/#signature_1", 
            "text": "Valid return types:  VertexFrame  or  Iterator  or  List  or  Set  Retrieves one or more of the adjacent vertex. If the return type is a single Frame then only the first instance is\nreturned. If the return type is an  Iterator  or  List  or  Set  then it will supply all matching edges. When using an Iterator  or  List  or  Set  it is encouraged, but not required, to use generics. The returned frames will always be\ninstantiated as the type encoded in the graph if there is one.   Note  If a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown.\nTherefore the return type specifed should always by the same type, or a superclass, of the expected return type.\nVertexFrame is always a safe return type for this method.   example:  @Incidence ( Foo )  FooEdge   getFoobar ();   @Incidence ( Foo )  E   extends   FooEdge   E   getFoobar ();   @Incidence ( Foo )  E   extends   EdgeFrame   E   getFoobar ();   @Incidence ( Foo )  Iterator FooEdge   getFoobar ();   @Incidence ( Foo )  E   extends   FooEdge   Iterator E   getFoobar ();   @Incidence ( Foo )  E   extends   EdgeFrame   Iterator E   getFoobar ();   @Incidence ( Foo )  List FooEdge   getFoobar ();   @Incidence ( Foo ,   direction   =   Direction . IN )  Set FooEdge   getFoobar ();   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . GET )  FooEdge   obtainFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/incidence/#signature-class", 
            "text": "Valid return types:  VertexFrame  or  Iterator  or  List  or  Set  Retrieves one or more of the adjacent edges. If the return type is a single  EdgeFrame  then only the first instance\nis returned. If the return type is an  Iterator  then it will iterate over all matching vertex. When using an Iterator\nit is encouraged to use generics.   Note  The Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype,\nto that of the argument will be returned.   example:  @Incidence ( Foo )  FooEdge   getFoobar ( Class ?   extends   FooEdge   filter );   @Incidence ( Foo )  E   extends   FooEdge   E   getFoobar ( Class ?   extends   E   filter );   @Incidence ( Foo )  E   extends   FooEdge   E   getFoobar ( Class ?   extends   E   filter );   @Incidence ( Foo )  Iterator FooEdge   getFoobar ( Class ?   extends   FooEdge   filter );   @Incidence ( Foo )  E   extends   FooEdge   Iterator E   getFoobar ( Class ?   extends   E   filter );   @Incidence ( Foo )  E   extends   EdgeFrame   Iterator E   getFoobar ( Class ?   extends   E   filter );   @Incidence ( Foo )  List FooEdge   getFoobar ( Class ?   extends   FooEdge   filter );   @Incidence ( Foo ,   direction   =   Direction . IN )  Set FooEdge   getFoobar ( Class ?   extends   FooEdge   filter );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . GET )  FooEdge   obtainFoobar ( Class ?   extends   FooEdge   filter );", 
            "title": "Signature: (Class)"
        }, 
        {
            "location": "/annotations/incidence/#remove-operation", 
            "text": "Valid method signatures:  (EdgeFrame)  Removes an edges which cause an adjacency, leaving the vertex in place.", 
            "title": "REMOVE Operation"
        }, 
        {
            "location": "/annotations/incidence/#signature-edgeframe", 
            "text": "Valid return types:  void  Removes the edge specified in the argument. This is entirely equivelant to just calling the  remove()  method on the EdgeFrame  example:  @Incidence ( Foo )  void   removeFoobar ( FooEdge   edge );   @Incidence ( Foo )  E   extends   FooEdge   void   removeFoobar ( E   edge );   @Incidence ( Foo ,   direction   =   Direction . IN )  E   extends   EdgeFrame   void   removeFoobar ( E   edge );   @Incidence ( value   =   Foo ,   operation   =   Adjacency . Operation . REMOVE )  void   removeFoobar ( FooEdge   edge );", 
            "title": "Signature: (EdgeFrame)"
        }, 
        {
            "location": "/annotations/invertex/", 
            "text": "Valid on frames: \nEdge\n\n\nAllowed prefixes when operation is AUTO: \nget\n\n\nThe \n@InVertex\n takes no parameters and is used only on get methods that themself take no parameters. It specifies the\n\nVertexFrame\n at the head of an edge.\n\n\nexample:\n\n\n@InVertex\n\n\n//Method declared here\n\n\n\n\n\nGET Operation\n\n\nValid method signatures: \n( )\n\n\nSignature: \n( )\n\n\nValid return types: \nVertexFrame\n.\n\n\nGet the head vertex of the edge.\n\n\nexample:\n\n\n@InVertex\n\n\nBarVertex\n \ngetFoobar\n();", 
            "title": "@InVertex"
        }, 
        {
            "location": "/annotations/invertex/#get-operation", 
            "text": "Valid method signatures:  ( )", 
            "title": "GET Operation"
        }, 
        {
            "location": "/annotations/invertex/#signature", 
            "text": "Valid return types:  VertexFrame .  Get the head vertex of the edge.  example:  @InVertex  BarVertex   getFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/outvertex/", 
            "text": "Valid on frames: \nEdge\n\n\nAllowed prefixes when operation is AUTO: \nget\n\n\nThe \n@OutVertex\n takes no parameters and is used only on get methods that themself take no parameters. It specifies the\n\nVertexFrame\n at the tail of an edge.\n\n\nexample:\n\n\n@OutVertex\n\n\n//Method declared here\n\n\n\n\n\nGET Operation\n\n\nValid method signatures: \n( )\n\n\nSignature: \n( )\n\n\nValid return types: \nVertexFrame\n.\n\n\nGet the tail vertex of the edge.\n\n\nexample:\n\n\n@OutVertex\n\n\nBarVertex\n \ngetFoobar\n();", 
            "title": "@OutVertex"
        }, 
        {
            "location": "/annotations/outvertex/#get-operation", 
            "text": "Valid method signatures:  ( )", 
            "title": "GET Operation"
        }, 
        {
            "location": "/annotations/outvertex/#signature", 
            "text": "Valid return types:  VertexFrame .  Get the tail vertex of the edge.  example:  @OutVertex  BarVertex   getFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/property/", 
            "text": "Valid on frames: \nEdge\n and \nVertex\n\n\nAllowed prefixes when operation is AUTO: \nget\n, \nis\n, \ncan\n, \nset\n, \nremove\n\n\nAnnotation arguments:\n\n\nvalue\n - The name of the property\n\n\noperation\n - The operation the method will perform. Must be one of the following: \nGET\n, \nSET\n, \nREMOVE\n, \nAUTO\n.\nDefaults to \nAUTO\n.\n\n\nThe following would bind the method it is used on to the property named \nfoo\n:\n\n\n@Property\n(\nfoo\n)\n\n\n//Method declared here\n\n\n\n\n\nGET Operation\n\n\nValid method signatures: \n( )\n\n\nSignature: \n( )\n\n\nValid return types: \nObject\n or any primitive.\n\n\nGet the property value of an element. Used when property is not a boolean value.\n\n\nexample:\n\n\n@Property\n(\nFoo\n)\n\n\nBar\n \ngetFoobar\n();\n\n\n\n\n\n@Property\n(\nFoo\n)\n\n\nE\n \nextends\n \nBar\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Property\n(\nFoo\n)\n\n\nE\n \nE\n \ngetFoobar\n();\n\n\n\n\n\n@Property\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nProperty\n.\nOperation\n.\nGET\n)\n\n\nBar\n \nobtainFoobar\n();\n\n\n\n\n\nGET Operation (is prefix)\n\n\nValid method signatures: \n( )\n\n\nSignature: \n( )\n\n\nValid return types: \nboolean\n\n\nGet the property value of an element. Used when property is a boolean value.\n\n\nexample:\n\n\n@Property\n(\nFoobared\n)\n\n\nboolean\n \nisFoobared\n();\n\n\n\n\n\n@Property\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nProperty\n.\nOperation\n.\nGET\n)\n\n\nboolean\n \nobtainFoobared\n();\n\n\n\n\n\nSET Operation\n\n\nValid method signatures: \n(Object)\n\n\nSignature: \n(Object)\n\n\nValid return types: \nvoid\n\n\nSet the property value of an element. The argument can be any class accepted by the underlying graph.\n\n\nexample:\n\n\n@Property\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nBar\n \nfoobar\n);\n\n\n\n\n\n@Property\n(\nFoo\n)\n\n\nE\n \nextends\n \nBar\n \nvoid\n \nsetFoobar\n(\nE\n \nfoobar\n);\n\n\n\n\n\n@Property\n(\nFoo\n)\n\n\nE\n \nextends\n \nVectorFrame\n \nvoid\n \nsetFoobar\n(\nE\n \nfoobar\n);\n\n\n\n\n\n@Property\n(\nFoo\n)\n\n\nvoid\n \nsetFoobar\n(\nBar\n \nfoobar\n);\n\n\n\n\n\n@Property\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nProperty\n.\nOperation\n.\nSET\n)\n\n\nvoid\n \napplyFoobar\n(\nBar\n \nfoobar\n);\n\n\n\n\n\nREMOVE Operation\n\n\nValid method signatures: \n( )\n\n\nSignature: \n( )\n\n\nValid return types: \nvoid\n\n\nRemove the property of an element.\n\n\nexample:\n\n\n@Property\n(\nFoo\n)\n\n\nvoid\n \nremoveFoobar\n();\n\n\n\n\n\n@Property\n(\nvalue\n \n=\n \nFoo\n,\n \noperation\n \n=\n \nProperty\n.\nOperation\n.\nREMOVE\n)\n\n\nvoid\n \nremoveFoobar\n();", 
            "title": "@Property"
        }, 
        {
            "location": "/annotations/property/#get-operation", 
            "text": "Valid method signatures:  ( )", 
            "title": "GET Operation"
        }, 
        {
            "location": "/annotations/property/#signature", 
            "text": "Valid return types:  Object  or any primitive.  Get the property value of an element. Used when property is not a boolean value.  example:  @Property ( Foo )  Bar   getFoobar ();   @Property ( Foo )  E   extends   Bar   E   getFoobar ();   @Property ( Foo )  E   E   getFoobar ();   @Property ( value   =   Foo ,   operation   =   Property . Operation . GET )  Bar   obtainFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/property/#get-operation-is-prefix", 
            "text": "Valid method signatures:  ( )", 
            "title": "GET Operation (is prefix)"
        }, 
        {
            "location": "/annotations/property/#signature_1", 
            "text": "Valid return types:  boolean  Get the property value of an element. Used when property is a boolean value.  example:  @Property ( Foobared )  boolean   isFoobared ();   @Property ( value   =   Foo ,   operation   =   Property . Operation . GET )  boolean   obtainFoobared ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/annotations/property/#set-operation", 
            "text": "Valid method signatures:  (Object)", 
            "title": "SET Operation"
        }, 
        {
            "location": "/annotations/property/#signature-object", 
            "text": "Valid return types:  void  Set the property value of an element. The argument can be any class accepted by the underlying graph.  example:  @Property ( Foo )  void   setFoobar ( Bar   foobar );   @Property ( Foo )  E   extends   Bar   void   setFoobar ( E   foobar );   @Property ( Foo )  E   extends   VectorFrame   void   setFoobar ( E   foobar );   @Property ( Foo )  void   setFoobar ( Bar   foobar );   @Property ( value   =   Foo ,   operation   =   Property . Operation . SET )  void   applyFoobar ( Bar   foobar );", 
            "title": "Signature: (Object)"
        }, 
        {
            "location": "/annotations/property/#remove-operation", 
            "text": "Valid method signatures:  ( )", 
            "title": "REMOVE Operation"
        }, 
        {
            "location": "/annotations/property/#signature_2", 
            "text": "Valid return types:  void  Remove the property of an element.  example:  @Property ( Foo )  void   removeFoobar ();   @Property ( value   =   Foo ,   operation   =   Property . Operation . REMOVE )  void   removeFoobar ();", 
            "title": "Signature: ( )"
        }, 
        {
            "location": "/comparing_the_alternatives/", 
            "text": "There are several OGM/ORM options out there. For the purposes of this document we will focus only on those that have a\nstable release, or are close to a stable release. At the time of this writing those are: Tinkerpop Framed and Totorom.\n\n\nBenchmarks\n\n\nWe maintain an informal project for benchmarking Ferma against other OGM available, you can find the\n\nsource here\n. However below is a matrix breakdown of the results. Instead\nof showing raw execution time we show the ratio of each OGM compared to Ferma. Therefore if the table lists 1x then it\nmeans the framework has the same execution time as Ferma, if it lists 2x then it took twice as long to execute, and if\nit indicates 0.5x then it took half the time to execute. Obviously any value less than 1x indicates the OGM out\nperformed Ferma and any value greater than 1x indicates Ferma had the superior performance tiimes.\n\n\n\n\n\n\n\n\n\n\nBlueprints\n\n\nGremlin Pipeline\n\n\nTinkerpop3\n\n\nFrames\n\n\nTotorom\n\n\nPeapod\n\n\n\n\n\n\n\n\n\n\nGet adjacencies via annotation\n\n\nNot capable\n\n\nNot capable\n\n\nNot capable\n\n\nx2.09\n\n\nNot capable\n\n\nx2.65\n\n\n\n\n\n\nGet verticies (untyped)\n\n\nx0.89\n\n\nx3.94\n\n\nx16.98\n\n\nNot capable\n\n\nx4.24\n\n\nNot capable\n\n\n\n\n\n\nGet verticies (typed)\n\n\nx0.92\n\n\nx3.94\n\n\nNot capable\n\n\nx0.96\n\n\nx4.20\n\n\nx20.74\n\n\n\n\n\n\nGet verticies and call next (untyped)\n\n\nx0.79\n\n\nx3.87\n\n\nx11.74\n\n\nNot capable\n\n\nx4.81\n\n\nNot capable\n\n\n\n\n\n\nGet verticies and call next (typed)\n\n\nx0.72\n\n\nx2.91\n\n\nNot capable\n\n\nx1.94\n\n\nx3.31\n\n\nx16.70\n\n\n\n\n\n\n\n\nAs can be seen Ferma out performs all the alternative solutions considerably by several orders of magnitude. While\nresults do vary slightly from system to system these results are pretty close to typical. Go ahead, check out the\nbenchmark program and run it for yourself!\n\n\nFeature Breakdown\n\n\nFerma also supports all the features provided by the alternatives out there, not to mention several novel features. The\nfollowing gives a quick breakdown of the features of the various frameworks. We also link to some Ferma examples showing\nthe various features in action.\n\n\n\n\n\n\n\n\nFeature\n\n\nFerma\n\n\nFrames\n\n\nTotorom\n\n\nPeapod\n\n\n\n\n\n\n\n\n\n\nJPA-like Annotations\n\n\nSupported\n\n\nSupported\n\n\nNot Supported\n\n\nSupported\n\n\n\n\n\n\nType information encoded into graph\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\n\n\n\n\nFraming of elements instantiated according to type hierarchy\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\n\n\n\n\nElement queried by type hierarchy\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nPartial *\n\n\n\n\n\n\nTurning off type resolution on a per call basis\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nNot Supported\n\n\n\n\n\n\nChanging the encoded graph type already stored in the database\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nNot Supported\n\n\n\n\n\n\nCustomizing the way type information is stored in the graph\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nNot Supported\n\n\n\n\n\n\nTinkerpop 2 support\n\n\nSupported\n\n\nSupported\n\n\nSupported\n\n\nNot Supported\n\n\n\n\n\n\nTinkerpop 3 support\n\n\nSupported\n\n\nNot Supported\n\n\nNot Supported\n\n\nSupported\n\n\n\n\n\n\n\n\n* While Peapod does support querying for all instances of a type, and its subtypes, it does not support a mechanism to\nquery for a specific type while excluding subtypes.", 
            "title": "Comparing the Alternatives"
        }, 
        {
            "location": "/comparing_the_alternatives/#benchmarks", 
            "text": "We maintain an informal project for benchmarking Ferma against other OGM available, you can find the source here . However below is a matrix breakdown of the results. Instead\nof showing raw execution time we show the ratio of each OGM compared to Ferma. Therefore if the table lists 1x then it\nmeans the framework has the same execution time as Ferma, if it lists 2x then it took twice as long to execute, and if\nit indicates 0.5x then it took half the time to execute. Obviously any value less than 1x indicates the OGM out\nperformed Ferma and any value greater than 1x indicates Ferma had the superior performance tiimes.      Blueprints  Gremlin Pipeline  Tinkerpop3  Frames  Totorom  Peapod      Get adjacencies via annotation  Not capable  Not capable  Not capable  x2.09  Not capable  x2.65    Get verticies (untyped)  x0.89  x3.94  x16.98  Not capable  x4.24  Not capable    Get verticies (typed)  x0.92  x3.94  Not capable  x0.96  x4.20  x20.74    Get verticies and call next (untyped)  x0.79  x3.87  x11.74  Not capable  x4.81  Not capable    Get verticies and call next (typed)  x0.72  x2.91  Not capable  x1.94  x3.31  x16.70     As can be seen Ferma out performs all the alternative solutions considerably by several orders of magnitude. While\nresults do vary slightly from system to system these results are pretty close to typical. Go ahead, check out the\nbenchmark program and run it for yourself!", 
            "title": "Benchmarks"
        }, 
        {
            "location": "/comparing_the_alternatives/#feature-breakdown", 
            "text": "Ferma also supports all the features provided by the alternatives out there, not to mention several novel features. The\nfollowing gives a quick breakdown of the features of the various frameworks. We also link to some Ferma examples showing\nthe various features in action.     Feature  Ferma  Frames  Totorom  Peapod      JPA-like Annotations  Supported  Supported  Not Supported  Supported    Type information encoded into graph  Supported  Supported  Supported  Supported    Framing of elements instantiated according to type hierarchy  Supported  Supported  Supported  Supported    Element queried by type hierarchy  Supported  Not Supported  Not Supported  Partial *    Turning off type resolution on a per call basis  Supported  Not Supported  Not Supported  Not Supported    Changing the encoded graph type already stored in the database  Supported  Not Supported  Not Supported  Not Supported    Customizing the way type information is stored in the graph  Supported  Not Supported  Not Supported  Not Supported    Tinkerpop 2 support  Supported  Supported  Supported  Not Supported    Tinkerpop 3 support  Supported  Not Supported  Not Supported  Supported     * While Peapod does support querying for all instances of a type, and its subtypes, it does not support a mechanism to\nquery for a specific type while excluding subtypes.", 
            "title": "Feature Breakdown"
        }, 
        {
            "location": "/glossary/", 
            "text": "Frame\n - A class from the schema that represents an element from the graph. A frame usually extends either a\n            VertexFrame or an EdgeFrame, though they are not required to do so.\n\n\nElement\n - Either a vertex or an edge in a graph.", 
            "title": "Glossary"
        }
    ]
}